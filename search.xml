<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>简单实现 Promise</title>
    <url>/hack/make-promise.html</url>
    <content><![CDATA[<p>Promise是前端异步回调的一个解决方案，更多的介绍其实网上都有。但是Promise规范有很多，如Promise/A，Promise/B，Promise/D 以及 Promise/A 的升级版Promise/A+。</p><a id="more"></a><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在阅读规范后，现在简单按照 Promise/A+ 的规范手撸一个简单的Promise对象。主要是为了加深认识Promise的规范和理解使用。</p><p><a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">【翻译】Promises/A+规范</a></p><h1 id="0x01-条件"><a href="#0x01-条件" class="headerlink" title="0x01 条件"></a>0x01 条件</h1><p>首先我们需要了解一个简单的Promise至少需要满足什么条件。</p><ol><li>Promise 的实例是具有状态的，而状态包括：等待态（Pending）、执行态（Fulfilled）、拒绝态（Rejected）。</li><li>一个 Promise 必须提供一个 then 方法以访问其当前值、终值和据因。</li></ol><h1 id="0x02-实现"><a href="#0x02-实现" class="headerlink" title="0x02 实现"></a>0x02 实现</h1><h2 id="02-1-定义"><a href="#02-1-定义" class="headerlink" title="02.1 定义"></a>02.1 定义</h2><p>首先我们通过一个立即执行匿名函数构建一个封闭的作用域，避免污染问题。</p><p>使用<code>Promise</code>的时候，我们都需要去创建一个新的实例，如:<code>new Promise(...)</code>，所以我们需要最后返回的是一个<code>Function</code>。</p><p><em>简单延伸一下，<code>new</code>做了什么操作：在Javascript中new是作为一个保留的关键词存在，其中new的操作是隐式的新建一个临时的空白对象，并拷贝了<code>function.prototype</code>的属性，最后将构造函数中的this指向这个临时新建的对象，最后返回这个临时对象</em></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> PromiseA = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> PENDING = <span class="number">0</span>; <span class="comment">//等待态</span></span><br><span class="line">  <span class="keyword">const</span> FULFILLED = <span class="number">1</span>; <span class="comment">//执行态</span></span><br><span class="line">  <span class="keyword">const</span> REJECTED = <span class="number">2</span>; <span class="comment">//拒绝态</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">PromiseA</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = PENDING;</span><br><span class="line">    <span class="keyword">this</span>.handlers = [];</span><br><span class="line">    fn(<span class="keyword">this</span>._resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>._reject.bind(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.assign(PromiseA.prototype,&#123;...&#125;) <span class="comment">// 后续逐个解释</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PromiseA;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><em>用于现在大部分浏览器都已经默认支持<code>Promise</code>对象，为了避免冲突所以另起<code>PromiseA</code>作为例子。</em></p><p>构造函数中默认赋值 <code>this.state = PENDING</code>，当实例新建的时候实例即处于等待状态。</p><p>由于规范中要求:_then 方法可以被同一个 promise 调用多次_。所以 <code>this.handlers = []</code>，用于在实例还处于PENDING状态时将多个 then 方法收集起来。</p><p><code>fn(this.resolve.bind(this), this.reject.bind(this))</code> 立即调用创建实例时传入的函数方法，并且将 resolve\reject 方法绑定当前 promise 实例后以参数形式传递。</p><p>到这里Promise的构造函数就写完了，接下来我们需要根据规范完成其他都应的方法。</p><h2 id="02-2-promise-then"><a href="#02-2-promise-then" class="headerlink" title="02.2 promise.then"></a>02.2 promise.then</h2><ul><li>promise 的 then 方法接受两个参数：<code>promise.then(onFulfilled, onRejected)</code></li><li>then 方法必须返回一个 promise 对象</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * promise 的 then 方法</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">PromiseA.prototype.then(onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._registerHandler(</span><br><span class="line">      result =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (onFulfilled &amp;&amp; onFulfilled <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">            resolve(onFulfilled(result));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      reason =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (onRejected &amp;&amp; onRejected <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">            resolve(onRejected(reason));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册then的回调方法，如果是PENDING状态则添加到队列。</span></span><br><span class="line"><span class="comment"> * 如果是FULFILLED 、 REJECTED 则直接执行方法</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">PromiseA.prototype._registerHandler(onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.handlers.push(&#123;</span><br><span class="line">      onFulfilled,</span><br><span class="line">      onRejected</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state === FULFILLED) &#123;</span><br><span class="line">        onFulfilled(<span class="keyword">this</span>.result);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的两个条件，我们知道每个then方法的返回值是 promise 对象，所以直接创建一个新的 Promise。</p><p><code>this._registerHandler</code> 这段代码中由于使用了箭头函数，所以 this 指向的是调用了 then 方法的 promise 实例，而非新创建的返回实例。<code>this._registerHandler</code> 将根据当前的 promise 实例状态判断执行不断的操作，如果当前状态是<code>PENDING</code>则将回调方法暂时存放在 handlers 中，如果是<code>FULFILLED</code>或者<code>REJECTED</code>则直接执行其中对应的回调。</p><p><code>this._registerHandler</code>接受的第一个参数是成功后的回调方法，第二个则是失败的。</p><blockquote><p>如果 onFulfilled 不是函数，其必须被忽略<br>如果 onRejected 不是函数，其必须被忽略</p></blockquote><p>根据规则，如果判断这两个参数不是函数，则直接跳过处理。但有个地方需要注意的是，经过<code>promise.then#onRejected</code>的方法处理后如果没有抛出新的错误或者返回一个新的<code>Promise.reject</code>，接下来的状态则应该是<code>FULFILLED</code>。</p><blockquote><p>如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x)</p></blockquote><p>最后要说的是为什么<code>setTimtou(,0)</code>，因为无论是静态值还是回调返回的值，当执行<code>resolve</code>后，then的回调方法都会放在微任务(mircoTask)队列中等待执行。所以这里简单用setTimeout模拟了。</p><h2 id="02-3-resolve-reject"><a href="#02-3-resolve-reject" class="headerlink" title="02.3 _resolve _reject"></a>02.3 _resolve _reject</h2><p>经过上面的代码热身大家应该能有一点感觉了，但其最核心主要的还是构造函数中的<code>fn(this._resolve.bind(this), this._reject.bind(this));</code>这段代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">PromiseA.prototype._resolve(result) &#123;</span><br><span class="line">  <span class="keyword">let</span> then = result &amp;&amp; <span class="keyword">this</span>._getThen(result);</span><br><span class="line">  <span class="keyword">if</span> (then) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      then.call(</span><br><span class="line">        result,</span><br><span class="line">        thenResult =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.state !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">          <span class="keyword">this</span>._fulfill(thenResult);</span><br><span class="line">        &#125;,</span><br><span class="line">        thenReason =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.state !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">          <span class="keyword">this</span>._reject(thenReason);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">this</span>._reject(e);</span><br><span class="line">      <span class="keyword">debugger</span>;</span><br><span class="line">      <span class="built_in">console</span>.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._fulfill(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PromiseA.prototype._getThen(result) &#123;</span><br><span class="line">  <span class="keyword">let</span> then = result.then;</span><br><span class="line">  <span class="keyword">if</span> (then &amp;&amp; then <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> then;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PromiseA.prototype._fulfill(result) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">this</span>.state = FULFILLED;</span><br><span class="line">  <span class="keyword">this</span>.result = result; <span class="comment">// 必须拥有一个不可变的终值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用回调函数</span></span><br><span class="line">  <span class="keyword">this</span>.handlers.forEach(<span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">    handler.onFulfilled(result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PromiseA.prototype._reject(reason) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">this</span>.state = REJECTED;</span><br><span class="line">  <span class="keyword">this</span>.reason = reason; <span class="comment">//必须拥有一个不可变的据因</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.handlers.forEach(<span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">    handler.onRejected(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们看下规则：</p><blockquote><p>x 为 Promise<br>如果 x 为 Promise ，则使 promise 接受 x 的状态 注4：<br>如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝<br>如果 x 处于执行态，用相同的值执行 promise<br>如果 x 处于拒绝态，用相同的据因拒绝 promise</p></blockquote><p><em>x指的是代码中的result</em></p><p>从规则中看到，我们需要在_resolve函数中判断返回值是否 Promise 对象，如果是的话需要等待这个<code>promise</code>直至被执行或者拒绝，这个时候我们需要对这个 promise 注册回调，当回调成功的时候则调用<code>this._fulfill</code>。如果不是 Promise 则直接调用 <code>this._fulfill</code>。</p><p>再看 <code>_getThen</code>，其实只是满足其中规则中定义的<code>thenable</code>(<em>是一个定义了 then 方法的对象或函数。</em>)去获取then方法。</p><p><code>_fulfill</code>、<code>_reject</code>。判断当前实例状态是否<code>PENDING</code>，因为根据状态中的规则来看只有<code>PENDING</code>可以迁移至执行态或拒绝态，并且不可逆。</p><h1 id="0x03-图解示例"><a href="#0x03-图解示例" class="headerlink" title="0x03 图解示例"></a>0x03 图解示例</h1><ol><li>创建一个新的Promise实例(promise1)时，创建的参数是一个函数，函数接收两个参数，分别是函数：resolve、reject。通过调用其中一个函数决定当前Promise实例处于何种状态。</li><li>当Promise实例调用then的时候，会立即创建一个新的Promise实例(thenPromise1)并返回。创建新的Promise时候，会在调用then的promise实例(promise1)中注册新的handler。</li><li>注册handler的时候，会判断promise实例(promise1)是否处于PENDING状态，如果是的话则将方法放入队列，否则直接执行对应状态的方法。</li></ol><p><img data-src="/images/promiseA.png" alt="promise"></p><h1 id="0x04-完整代码"><a href="#0x04-完整代码" class="headerlink" title="0x04 完整代码"></a>0x04 完整代码</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> PromiseA = (<span class="function"><span class="params">global</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> PENDING = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> FULFILLED = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> REJECTED = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">PromiseA</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = ++id;</span><br><span class="line">    <span class="keyword">this</span>.state = PENDING;</span><br><span class="line">    <span class="keyword">this</span>.handlers = [];</span><br><span class="line">    fn.call(global, <span class="keyword">this</span>._resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>._reject.bind(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.assign(PromiseA.prototype, &#123;</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._registerHandler(</span><br><span class="line">          result =&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (onFulfilled &amp;&amp; onFulfilled <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">                resolve(onFulfilled(result));</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(result);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">              reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          reason =&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (onRejected &amp;&amp; onRejected <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">                resolve(onRejected(reason));</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(reason);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">              reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    _resolve: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> then = result &amp;&amp; <span class="keyword">this</span>._getThen(result);</span><br><span class="line">      <span class="keyword">if</span> (then) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          then.call(</span><br><span class="line">            result,</span><br><span class="line">            thenResult =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.state !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">              <span class="keyword">this</span>._fulfill(thenResult);</span><br><span class="line">            &#125;,</span><br><span class="line">            thenReason =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.state !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">              <span class="keyword">this</span>._reject(thenReason);</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.state !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">          <span class="keyword">this</span>._reject(e);</span><br><span class="line">          <span class="keyword">debugger</span>;</span><br><span class="line">          <span class="built_in">console</span>.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._fulfill(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    _reject(reason) &#123;</span><br><span class="line">      <span class="keyword">this</span>._reject(reason);</span><br><span class="line">    &#125;,</span><br><span class="line">    _registerHandler(onFulfilled, onRejected) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handlers.push(&#123;</span><br><span class="line">          onFulfilled,</span><br><span class="line">          onRejected</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.state === FULFILLED) &#123;</span><br><span class="line">            onFulfilled(<span class="keyword">this</span>.result);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    _fulfill(result) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">this</span>.state = FULFILLED;</span><br><span class="line">      <span class="keyword">this</span>.result = result;</span><br><span class="line">      <span class="keyword">this</span>.handlers.forEach(<span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">debugger</span>;</span><br><span class="line">        handler.onFulfilled(result);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    _reject(reason) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">this</span>.state = REJECTED;</span><br><span class="line">      <span class="keyword">this</span>.reason = reason;</span><br><span class="line">      <span class="keyword">this</span>.handlers.forEach(<span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">        handler.onRejected(reason);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    _getThen(result) &#123;</span><br><span class="line">      <span class="keyword">let</span> then = result.then;</span><br><span class="line">      <span class="keyword">if</span> (then &amp;&amp; then <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> then;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PromiseA;</span><br><span class="line">&#125;)(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h1 id="0x05-最后"><a href="#0x05-最后" class="headerlink" title="0x05 最后"></a>0x05 最后</h1><p><code>PromiseA.resolve</code> 的实现其实也很简单，各类扩展的方法就不展开讨论。最后简单的说一下<code>PromiseA.resolve</code>的函数怎么实现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> PromiseA = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">PromiseA</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = PENDING;</span><br><span class="line">    <span class="keyword">this</span>.handlers = [];</span><br><span class="line">    fn(<span class="keyword">this</span>._resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>._reject.bind(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  PromiseA.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function"><span class="params">resolve</span>=&gt;</span>resolve(result));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PromiseA;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>用 SVG 做个动画</title>
    <url>/hack/svg-animation.html</url>
    <content><![CDATA[<p>现代网页前端开发实现动画效果相比以往的Flash、GIF越发丰富和成熟，其中就包括了CSS3、Canvas、SVG。利用CSS3可以使DOM元素根据设置好的动画过程动起来，Canvas即可以通过JavaScript在画布上绘画出各种图案。今天要说SVG则有别于两者，SVG最初是XML家族作为一种通用的数据格式，后逐渐发展到今天成为一种图像的数据甚至有着不断发展成为Every Things的潜力。</p><a id="more"></a><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><p>SVG 全称 Scalable Vector Graphics，可缩放矢量图形。是一种用XML语言描述的二位矢量图形格式。由 W3C 制定，是一个开放的标准。更多的可以看 <a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%B8%AE%E6%94%BE%E5%90%91%E9%87%8F%E5%9C%96%E5%BD%A2" target="_blank" rel="noopener">wiki</a> 。</p><h3 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h3><p>1996年 Chris Lilley 起草了一份Web的矢量图形需求，到1998年就已经有六个方案提交到 W3C 中：</p><ul><li>Web Schematics, 由 CCLRC(Science and Technology Facilities Council) 提交。</li><li>PGML, 由 Adobe, IBM, Netscape, 和 Sun 提交</li><li>VML, 由 Autodesk, Hewlett-Packard, Macromedia, 和 Microsoft 提交</li><li>Hyper Graphics Markup Language, 由 Orange, PCSL, 和 PRP 提交</li><li>WebCGM, 由 Boeing, CCLRC, Inso, JISC, 和 Xerox 提交</li><li>DrawML, 由 Excosoft 提交</li></ul><p>当时 W3C 并不想 Web 上的矢量图片被这些企业巨头所垄断，随后就成立了一个专门小组 SVG Working Group，以借鉴 PGML 和 VML 两种提案后，提出了 SVG 规范。</p><p><em>小插曲：Adobe说 PGML 仅仅只是一份提议，很高兴去修改它。不过 Microsoft 说 VML 已经应用到商业产品上的文档，W3C 无权去进行任何更改</em></p><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><p>2011年8月16日，W3C 发布了 SVG 1.1（第2版），也是 W3C 目前推荐的标准。2017年的今天，几乎所有现代浏览器已经实现了对 SVG 基础的支持，全球浏览器支持率达 97.88% ，中国为 93.34%。</p><ul><li>IE 9.0 及以上。</li><li>Firefox 、Chrome 几乎全部支持。</li><li>Android 4.4 及以上。</li><li>IOS 几乎全部支持。</li></ul><p>SVG 相比一般常用的jpeg、png、gif图像格式，它具有可读性（XML）、可嵌入脚本、时序控制和动画、方便创建文字索引等特性。在这些特性的支持下，作为 Web 前端开发者就能利用 SVG 创作更多的可能性，本文将会一一介绍和通过简单的例子来展现出 SVG 的强大。</p><p>通过上面的描述来看，从今天开始学习并且使用 SVG 都能得到良好的支持。更何况 Adobe 的AI、PS已经支持导出 SVG 的情况下，能更好的配合设计妹子的工作。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>通过上面对 SVG 的了解，我们可以清晰的知道它是一种以XML为基础的“结构化数据”，相信对于前端开发者们驾轻就熟了。SVG 涉及的元素就多达94个（来自<a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element" target="_blank" rel="noopener">SVG element reference</a>所列出的），元素分类就足足有19项，其中包括了一些动画元素、基础图形、容器元素、描述元素、过滤原始元素……但从这些数字来看就证明 SVG 的功能足够的丰富。</p><h3 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h3><p>在现代浏览器井喷式发展的背后，各个浏览器对 SVG 的支持也在不断跟进发展，其中已知使用的方法就包含了：</p><ul><li>使用 <code>&lt;img&gt;</code> 标签，通过 src 属性载入一个 *.svg 文件，将 SVG 与传统的互联网图片格式同等使用。<strong>(常见)</strong></li><li>使用 <code>&lt;svg&gt;</code> 标签，在 html 文件上进行定义。<strong>(常见)</strong></li><li>使用 <code>&lt;embed&gt;</code> 标签，Adobe 公司为不原生支持 SVG 的浏览器开发的插件 Adobe SVG Viewer。（2009年1月1日 Adobe 已终止支持）</li><li>使用 <code>&lt;object&gt;</code> 标签，通过 data 属性载入一个 *.svg 文件。</li><li>使用 <code>&lt;iframe&gt;</code> 标签，通过 src 属性载入一个 *.svg 文件。</li></ul><p>但按照目前的浏览器发展进程，前两种方法已经得到很好的支持，所以推荐大家只需使用前两种即可。</p><h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>我们首先学习最简单的例子，如何画出一个红色的“X”。这是相当基础的一个绘图，我们需要定义一个画布其中包括画布的宽高，在画布上根据各自坐标系画出两条交叉的线。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--  第一条线从 (20,100) 开始画一条直线到 (100,20)  --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">"20"</span> <span class="attr">y1</span>=<span class="string">"100"</span> <span class="attr">x2</span>=<span class="string">"100"</span> <span class="attr">y2</span>=<span class="string">"20"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">stroke-width</span>=<span class="string">"2"</span> <span class="attr">stroke</span>=<span class="string">"red"</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--  第二条线 (100,100) 开始画一条直线到 (20,20)  --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">"100"</span> <span class="attr">y1</span>=<span class="string">"100"</span> <span class="attr">x2</span>=<span class="string">"20"</span> <span class="attr">y2</span>=<span class="string">"20"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">stroke-width</span>=<span class="string">"2"</span> <span class="attr">stroke</span>=<span class="string">"red"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><iframe height="265" scrolling="no" title="SVG -- A red X" src="//codepen.io/zqjimlove/embed/jmeLgx/?height=265&theme-id=0&default-tab=result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen style="width:100%">See the Pen <a href="http://codepen.io/zqjimlove/pen/jmeLgx/" target="_blank" rel="noopener">SVG -- A red X</a> by JimWoo (<a href="http://codepen.io/zqjimlove" target="_blank" rel="noopener">@zqjimlove</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</iframe><h2 id="实现动画"><a href="#实现动画" class="headerlink" title="实现动画"></a>实现动画</h2><p>SVG 在最初提案的时候就加入了对动画实现的考虑，SVG 的动画是通过 W3C 颁布的另一种动画语言 SIML(Synchronized Multimedia Integration Language)实现。</p><p>SIML 与 SVG 一样，都是一种声明性的标记语言，通过元素和元素的属性来定义动画的行为。所以在使用 SVG 实现动画过程中 SIML 语言的元素也作为 SVG 的元素一样定义在 <code>&lt;svg&gt;</code> 标签内。</p><h3 id="animate"><a href="#animate" class="headerlink" title="animate"></a>animate</h3><p><code>&lt;animate&gt;</code>，通过改变父元素的属性的值达到动画的效果。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"120"</span> <span class="attr">height</span>=<span class="string">"120"</span> <span class="attr">viewPort</span>=<span class="string">"0 0 120 120"</span> <span class="attr">version</span>=<span class="string">"1.1"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span>&gt;</span>·</span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">"10"</span> <span class="attr">y</span>=<span class="string">"10"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">animate</span> <span class="attr">attributeType</span>=<span class="string">"XML"</span> <span class="attr">attributeName</span>=<span class="string">"x"</span> <span class="attr">from</span>=<span class="string">"-100"</span> <span class="attr">to</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">dur</span>=<span class="string">"10s"</span> <span class="attr">repeatCount</span>=<span class="string">"indefinite"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>【解读代码】</strong></p><ul><li><code>&lt;rect&gt;</code>添加子动画元素<code>&lt;animate&gt;</code>。</li><li>设置改变的属性（<code>attributeName</code>）为”x”。</li><li>设置“x”的值从（<code>from</code>） -100 到（<code>to</code>） 120 进行改变。</li><li>动画时长（dur）10s。</li><li>重复次数（repeatCount）无限重复。</li></ul><p><em><code>&lt;animateColor&gt;</code> 元素会在未来的标准中删除，如果需要修改颜色可以利用<code>&lt;animate&gt;</code>实现</em></p><h3 id="animateMotion"><a href="#animateMotion" class="headerlink" title="animateMotion"></a>animateMotion</h3><p><code>&lt;animateMotion&gt;</code>根据路径(<code>&lt;path&gt;</code>)进行位移运动。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"120"</span> <span class="attr">height</span>=<span class="string">"120"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 120 120"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--运动路径--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M10,110 A120,120 -45 0,1 110 10 A120,120 -45 0,1 10,110"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">stroke</span>=<span class="string">"lightgrey"</span> <span class="attr">stroke-width</span>=<span class="string">"2"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">fill</span>=<span class="string">"none"</span> <span class="attr">id</span>=<span class="string">"theMotionPath"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--运动的红点--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">""</span> <span class="attr">cy</span>=<span class="string">""</span> <span class="attr">r</span>=<span class="string">"5"</span> <span class="attr">fill</span>=<span class="string">"red"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义动画元素--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">animateMotion</span> <span class="attr">dur</span>=<span class="string">"6s"</span> <span class="attr">repeatCount</span>=<span class="string">"indefinite"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--链接路径--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mpath</span> <span class="attr">xlink:href</span>=<span class="string">"#theMotionPath"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">animateMotion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">circle</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>【解读代码】</strong></p><ul><li>使用<code>&lt;path&gt;</code>元素定义运动路径。</li><li>定义<code>&lt;animateMotion&gt;</code>元素，然后利用<code>&lt;mpath&gt;</code>引入运动的目标路径。</li><li>动画时长（dur）6s。</li><li>重复次数（repeatCount）无限重复。</li></ul><p>由于<code>&lt;path&gt;</code>涵盖的内容较多，说起来会导致篇幅过大所以在这里不进行详述，日后新开一篇文章进行详述。如果有需要可以阅读<a href="https://github.com/GcsSloop/AndroidNote/blob/master/CustomView/README.md" target="_blank" rel="noopener">GcsSloop的文章</a></p><h3 id="animateTransform"><a href="#animateTransform" class="headerlink" title="animateTransform"></a>animateTransform</h3><p><code>&lt;animateTransform&gt;</code>改变父元素的变形属性，从而允许动画控制转换、缩放、旋转或斜切。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"120"</span> <span class="attr">height</span>=<span class="string">"120"</span>  <span class="attr">viewBox</span>=<span class="string">"0 0 120 120"</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--多边形--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polygon</span> <span class="attr">points</span>=<span class="string">"60,30 90,90 30,90"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义表行属性动画--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">animateTransform</span> <span class="attr">attributeName</span>=<span class="string">"transform"</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">attributeType</span>=<span class="string">"XML"</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">type</span>=<span class="string">"rotate"</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">from</span>=<span class="string">"0 60 70"</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">to</span>=<span class="string">"360 60 70"</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">dur</span>=<span class="string">"10s"</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">repeatCount</span>=<span class="string">"indefinite"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">polygon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>【解读代码】</strong></p><ul><li>定义旋转（<code>type=&quot;rotate&quot;</code>）的动画，其他值：”translate”, “scale”, “skewX” 或 “skewY”。</li><li>其中 <code>from</code> 和 <code>to</code> 有三个值 n1 n2 n3</li><li>旋转动画从 0度 到 360度。 (n1的值)</li><li>旋转的圆心坐标为60,70。 (n2,n3 的值)。</li><li>动画时长（dur）4s。</li><li>重复次数（repeatCount）无限重复。</li></ul><h3 id="discard"><a href="#discard" class="headerlink" title="discard"></a>discard</h3><p>当添加子元素 <code>&lt;discard&gt;</code> 的时候，该元素会在指定时间内被消除，从而帮助浏览器释放更多的内存，对于较大的多个svg元素组成的动画有一定帮助。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"120"</span> <span class="attr">height</span>=<span class="string">"120"</span>  <span class="attr">viewBox</span>=<span class="string">"0 0 120 120"</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--多边形--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polygon</span> <span class="attr">points</span>=<span class="string">"60,30 90,90 30,90"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将在1.2s后被消除--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">discard</span> <span class="attr">begin</span>=<span class="string">"1.2s"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">polygon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="利用脚本处理动画"><a href="#利用脚本处理动画" class="headerlink" title="利用脚本处理动画"></a>利用脚本处理动画</h2><p>上面说到了 SVG 可以利用本身的元素进行一些相对简单的动画效果，但是这种实现方式需要和用户进行交互的时候就显得不好控制了，所以在 SVG 最初的设计过程中就考虑到了可编程性的需求，作为被用于互联网的一个技术，所以通过 JavaScript 和 DOM 访问它就是成了最重要的应用模式。</p><p>下面将会结合 JavaScript 和大家学习一下 SVG 的可编程性。</p><h3 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h3><p>进度条是我们在应用开发过程中最容易接触到的元素，以往我们在编写进度条的样式往往是通过修改元素的宽带来达到进度条的效果。但想要酷炫的进度条我们就要使用 SVG 了。其实在 HTML 里直接编写和使用 SVG 过程中我们都可以通过 JavaScript 直接反问或者修改元素的值。</p><p>下面我们就用一个进度条来演示一下，JavaScript 如何动态修改 SVG 的元素以达到进度条加载的效果。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span> 进度条 <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">'JavaScript'</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">ProgressBar</span><span class="params">(info)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> stem = &#123;&#125;; <span class="comment">// 此函数最后返回的代表进度条的对象。</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> done = <span class="number">0</span>, length, outline, bar; <span class="comment">// 声明内部变量。</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">      bar = <span class="built_in">document</span>.getElementById(<span class="string">"done"</span>); <span class="comment">// 进度条中绿色的变化部分。</span></span></span><br><span class="line">      length = 80;</span><br><span class="line">    </span><br><span class="line"><span class="actionscript">      <span class="comment">// 重置进度到零。</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> to(<span class="number">0</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="comment">// 设置进度到某个值。</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">to</span><span class="params">(value)</span> </span>&#123;</span></span><br><span class="line">        if (value &gt;= 100) &#123;</span><br><span class="line">          done = 100;</span><br><span class="line"><span class="actionscript">          bar.setAttribute(<span class="string">"width"</span>, length);</span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">          done = value;</span><br><span class="line"><span class="javascript">          bar.setAttribute(<span class="string">"width"</span>, <span class="built_in">Math</span>.round(done * length / <span class="number">100</span>));</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> stem;</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="comment">// 进度变化某个值。</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">advance</span><span class="params">(step)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> to(done + step);</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="comment">// 以下给进度条对象添加方法。</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 获得当前进度值。</span></span></span><br><span class="line"><span class="actionscript">      stem.getDone = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> done;</span></span><br><span class="line">      &#125;;</span><br><span class="line">      stem.reset = reset;</span><br><span class="line">      stem.to = to;</span><br><span class="line">      stem.advance = advance;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> stem; <span class="comment">// 返回可供脚本使用的进度条对象。</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">// 测试进度条对象。</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">testBar</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> bar = ProgressBar();</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 此内部函数每运行一次，增加进度值 1，直到进度值为 100。</span></span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">        if (bar.getDone() === 100) &#123;</span><br><span class="line">          clearInterval(id);</span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">          bar.advance(1);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="comment">// 每十分之一秒改变一次进度。</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> id = setInterval(test, <span class="number">100</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">// 页面载入后开始测试。</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>, testBar, <span class="literal">true</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'svgDiv'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewBox</span>=<span class="string">"0 0 100 100"</span> <span class="attr">style</span>=<span class="string">"border:1px solid; width:200px; height:200px; "</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!--定义一个进度条组(Group)--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">'progBar'</span>&gt;</span> </span><br><span class="line">             <span class="comment">&lt;!--进度条的外框，灰色边框白色背景。--&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">'10'</span> <span class="attr">y</span>=<span class="string">'40'</span> <span class="attr">width</span>=<span class="string">'80'</span> <span class="attr">height</span>=<span class="string">'20'</span> <span class="attr">stroke</span>=<span class="string">'grey'</span> <span class="attr">fill</span>=<span class="string">'white'</span>/&gt;</span> </span><br><span class="line">             <span class="comment">&lt;!--进度条绿色部分--&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">rect</span> <span class="attr">id</span>=<span class="string">'done'</span> <span class="attr">x</span>=<span class="string">'10'</span> <span class="attr">y</span>=<span class="string">'40'</span> <span class="attr">width</span>=<span class="string">'0'</span> <span class="attr">height</span>=<span class="string">'20'</span> <span class="attr">fill</span>=<span class="string">'green'</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">g</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>【解读代码】</strong></p><ul><li>先定义 HTML 元素。</li><li>定义一个 SVG 元素，并设置 viewBox 为 0,0,100,100。（viewBox 的设置也牵扯到很多学问，日后再开一篇文章说说。）</li><li>定义一个容器元素 <code>&lt;g&gt;</code> 用于分组，id 为 “progBar” 。</li><li>在 progBar 容器中添加两个矩形元素。第一个作为外层边框，第二个作为绿色的层显示进度并定义。</li><li>在 JavaScript 脚本中我们用 DOM 获得绿色矩形并且进行属性修改。</li></ul><p>SVG 可以结合脚本代码使用最大的好处就是可以用户产生交互， JavaScript 对 SVG 的操作和平常对 DOM 的操作并无太大不同，getElementById 和 setAttribute 的用法和在 HTML 中没有两样。而且这些脚本代码也可以存放在 *.svg 文件中，只不过在 *.svg 文件中 script 标签后需要在两侧加上 CDATA 标注。如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">'JavaScript'</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">/* &lt;![CDATA[ */</span></span></span><br><span class="line">    ....</span><br><span class="line"><span class="actionscript">    <span class="comment">/* ]]&gt; */</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="性能的比较"><a href="#性能的比较" class="headerlink" title="性能的比较"></a>性能的比较</h2><p>SVG 和 Canvas 的性能对比上，其实都有优劣。在屏幕越大的情况下 Canvas 因为需要绘制的像素更多，所以性能越低。但在对象越多的情况下，SVG 就显得力不从心因为过多的对象也是会加入到 DOM 中的。如果想要了解更多，可以看 <a href="https://segmentfault.com/a/1190000002435534" target="_blank" rel="noopener">Canvas 与 SVG</a> 的对比。</p><p>SVG 和 GIF 图片的对比也是部分读者关心的，毕竟有时候我们一些状态图标就在使用 gif 格式的图片。GIF 和 SVG 最大的区别就是，SVG 是矢量图可以在无限放大的情况下仍然保持清晰，而 GIF 就没办法做到了。在对比加载过程中 GIF 图片往往很大而且无法通过 gzip 压缩，而 SVG 由于是属于 XML 的结构文档可以被 gzip 进行压缩，所以相对 GIF 图片来说 SVG 加载速度更快。如果想要了解更多，可以看 <a href="https://sarasoueidan.com/blog/svg-vs-gif/" target="_blank" rel="noopener">Animated SVG vs GIF</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SVG 的好处在于方便的可编辑、可通过 JavaScript 控制等，而且随着浏览器的快速发展越来越多的浏览器对其支持并且逐渐完善更多的标准。而且 Adobe 的一系列软件可以将动画导出称为一个 SVG 格式的文件。在如此之多的优势下，我们还有什么理由不使用 SVG 呢？</p>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>认识 Web Audio API</title>
    <url>/hack/learn-web-audio-api.html</url>
    <content><![CDATA[<p>HTML5 在做游戏方面越来越完善，虽然在性能上还是不尽如人意但做一些简单的游戏仍然是能满足大部分需求的。画面和音效作为游戏的重要元素两者缺一不可，HTML5的canvas作为画面的渲染等都已经很成熟了，在音效方面也有Web Audio API 作为支持。</p><p>这一篇文章主要简单介绍一下Web Audio API的应用。</p><a id="more"></a><h1 id="初识HTML5音频"><a href="#初识HTML5音频" class="headerlink" title="初识HTML5音频"></a>初识HTML5音频</h1><p><code>&lt;audio&gt;</code>应该是最为简单而且为人熟知的标签，一般用于在文档中表示音频内容，可以很简单的指定一个音频源。通常使用场景都是作为背景音乐、歌曲等播放。</p><p>虽然都是能达到播放音频的效果，但在作为游戏音效中有一个致命的问题就是频繁在停止和播放过程中切换会导致卡顿甚至播放没有声音等现象。对于一些打击音效来说使用<code>&lt;audio&gt;</code>会导致画面和音效不同步时有发生。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext" target="_blank" rel="noopener">AudioContext</a> 是作为音频播放的基础。不同于 <code>&lt;Audio&gt;</code>，其功能完全由 JavaScript 控制，在事件上的控制相比<code>&lt;Audio&gt;</code>更完善因为它实现了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget" target="_blank" rel="noopener">EventTarget</a>的接口，在音频源上可以利用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioBuffer" target="_blank" rel="noopener">AudioBuffer</a>进行多音频编辑或者捕捉处理等，甚至能对音频进行混响、双二阶滤波器、平移、压缩处理。</p><h1 id="使用-Web-Audio-API"><a href="#使用-Web-Audio-API" class="headerlink" title="使用 Web Audio API"></a>使用 Web Audio API</h1><p>Web Audio API最大的优点在于通过音频节点的输入输出相连，通常开始播放都是从一个或多个源。事实上，声音文件只是自身声音声频的记录，这些节点的输出可以链接到其他节点的输入，将这些声音流经过混合或修改后形成其他的流，常见的修改就是将样本乘以一个值，使其声音更加响亮或安静。</p><h3 id="开始之前，先了解一下工作模式"><a href="#开始之前，先了解一下工作模式" class="headerlink" title="开始之前，先了解一下工作模式"></a>开始之前，先了解一下工作模式</h3><ol><li>创建音频上下文</li><li>在上下文中，创建音频源 —— 例如： <code>&lt;audio&gt;</code>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/OscillatorNode" target="_blank" rel="noopener">OscillatorNode</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamAudioSourceNode" target="_blank" rel="noopener">流</a></li><li>创建效果节点 —— 例如：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ConvolverNode" target="_blank" rel="noopener">混响</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/BiquadFilterNode" target="_blank" rel="noopener">滤波器</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PannerNode" target="_blank" rel="noopener">平移</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DynamicsCompressorNode" target="_blank" rel="noopener">压缩</a></li><li>为音频选择一个终端，例如你的系统扬声器。</li><li>连接源到效果器，以及效果器到终端。</li></ol><p><img data-src="/images/web-audio-api-flowchart.png" alt="web-audio-api-flowchart"></p><h3 id="创建-AudioContext"><a href="#创建-AudioContext" class="headerlink" title="创建 AudioContext"></a>创建 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext" target="_blank" rel="noopener"><code>AudioContext</code></a></h3><p><code>AudioContext</code> 是用于管理和播放所有声音。为了使Web Audio API有声音，创建一个或者多个音源并把他们连接到由 <code>AudioContext</code> 提供的终端，而且该连接不需要直接连接的，可以经过任何数量的 <code>AudioNodes</code> 充当音频信号的处理器。</p><p>一个 <code>AudioContext</code> 的实例可以支持多个音频输入和复杂的音频图形，所以很多时候我们只需创建一个实例即可。而且 <code>AudioContext</code> 的方法使 Web Audio API 变得十分有趣。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化创建音频上下文</span></span><br><span class="line"><span class="comment">// 由于部分浏览器需要webkit前缀，所以这里做了个兼容处理。</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">new</span> (<span class="built_in">window</span>.AudioContext || <span class="built_in">window</span>.webkitAudioContext)(); </span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    alert(<span class="string">'Web Audio API is not supported in this browser'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载音频"><a href="#加载音频" class="headerlink" title="加载音频"></a>加载音频</h3><p>Web Audio API 使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer" target="_blank" rel="noopener"><code>AudioBuffer</code></a> 作为短、中长度的音频源。而且都是通过 <code>XMLHttpRequest</code> 进行异步加载这些音频文件的。</p><p>Web Audio API 支持多种格式的加载，例如：WAV、MP3、ACC、OGG等。可以通过 MDN 提供的<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats#Browser_compatibility" target="_blank" rel="noopener">表格</a>查看详情。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dogBarkingBuffer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> context = <span class="keyword">new</span> (<span class="built_in">window</span>.AudioContext || <span class="built_in">window</span>.webkitAudioContext)(); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadDogSound</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 异步获取音频文件</span></span><br><span class="line">  <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  request.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line">  request.responseType = <span class="string">'arraybuffer'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载成功后进行解码操作</span></span><br><span class="line">  request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    context.decodeAudioData(request.response, <span class="function"><span class="keyword">function</span>(<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获得 AudioBuffer</span></span><br><span class="line">      dogBarkingBuffer = buffer;</span><br><span class="line">    &#125;, onError);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发起请求</span></span><br><span class="line">  request.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于音频文件的数据是二进制（非文本），所以要设置请求头的<code>responseType</code>为<code>arraybuffer</code>。</p><p>当异步加载完文件后需要利用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/decodeAudioData" target="_blank" rel="noopener"><code>AudioContext.decodeAudioData()</code></a>进行解码，如果是原始数据（raw data）则使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createBuffer" target="_blank" rel="noopener"><code>AudioContext.createBuffer()</code></a>，一旦放入 <code>AudioBuffer</code> 就可以通过传递放入到 <code>AudioBufferSourceNode</code> 进行播放。</p><p>当<code>decodeAudioData</code>完成后，它会执行回调并且传递一个参数是一个已经解码了的<code>AudioBuffer</code>音频数据。</p><h3 id="播放音频"><a href="#播放音频" class="headerlink" title="播放音频"></a>播放音频</h3><p>一旦一个或者多个 <code>AudioBuffer</code> 被加载完成，然后我们就可以准备播放这些音频了。接下来我们就能通过以下的代码来播放刚才加载的音频。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">playSound</span>(<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> source = context.createBufferSource(); <span class="comment">// 利用上下文创建一个源缓冲器</span></span><br><span class="line">  source.buffer = buffer;          <span class="comment">// 设置源的数据</span></span><br><span class="line">  source.connect(context.destination);       <span class="comment">// 连接源到终端（默认是系统扬声器/耳机）</span></span><br><span class="line">  source.start(<span class="number">0</span>);                           <span class="comment">// 立即播放</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要注意的是，在一些旧的系统中是调用 noteOn(time)</span></span><br><span class="line">  <span class="comment">// 详情查看：https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Porting_webkitAudioContext_code_to_standards_based_AudioContext</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在任何时间当用户按下键盘或者鼠标， <code>playSound(buffer)</code> 方法都是可以调用的。</p><p>而 <code>start(time)</code> 可以很方便地为游戏或者其他关键时间进行精确的声音播放。但首先要确保的是 <code>AudioBuffer</code> 已经预加载。（由于部分旧系统采用的是旧的API，所以播放需要使用<code>noteOn(time)</code>，<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Porting_webkitAudioContext_code_to_standards_based_AudioContext" target="_blank" rel="noopener">更多的API变更信息</a>）</p><p><strong>值得注意的是</strong>，在iOS上，用户进行第一次交互之前所有声音都是被设置为静音的。所以需要用户在屏幕上触摸一下才能正常工作。</p><h3 id="播放时间处理"><a href="#播放时间处理" class="headerlink" title="播放时间处理"></a>播放时间处理</h3><p>Web Audio API 允许开发人员可以精确地处理播放时间。下面我们设置一个简单的节奏音乐。</p><p><img data-src="/images/web_audio_api_drum.png" alt="web_audio_api_drum"></p><p>上面是一份4/4拍的谱子，其中每八分音符就播放一次踩钹，贝司和小鼓轮流播放。</p><p>假如我们已经缓冲了贝司、小鼓、踩钹的数据：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> bar = <span class="number">0</span>; bar &lt; <span class="number">2</span>; bar++) &#123;</span><br><span class="line">  <span class="keyword">var</span> time = startTime + bar * <span class="number">8</span> * eighthNoteTime;</span><br><span class="line">  <span class="comment">// 在1、5拍时播放贝司</span></span><br><span class="line">  playSound(kick, time);</span><br><span class="line">  playSound(kick, time + <span class="number">4</span> * eighthNoteTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在3、7拍shi时播放小鼓</span></span><br><span class="line">  playSound(snare, time + <span class="number">2</span> * eighthNoteTime);</span><br><span class="line">  playSound(snare, time + <span class="number">6</span> * eighthNoteTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每八分拍播放一次踩钹</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">    playSound(hihat, time + i * eighthNoteTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script async src="//jsfiddle.net/jimwoo/19aer39a/embed/result/"></script><p>在上面的例子里，我们在<code>playSound</code>方法中是指定了时间进行播放的。</p><h3 id="改变音量"><a href="#改变音量" class="headerlink" title="改变音量"></a>改变音量</h3><p>在最基本的操作之一就是控制音量的大小，在Web Audio API中，我们可以利用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GainNode" target="_blank" rel="noopener"><code>GainNode</code></a>作为处理器，然后再输出到终端。</p><p><img data-src="/images/web-audio-api-GainNode.png" alt="web-audio-api-GainNode.png"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个增益处理器</span></span><br><span class="line"><span class="keyword">var</span> gainNode = context.createGain();</span><br><span class="line"><span class="comment">// 将源连接到增益处理器</span></span><br><span class="line">source.connect(gainNode);</span><br><span class="line"><span class="comment">// 将增益处理连接到终端</span></span><br><span class="line">gainNode.connect(context.destination);</span><br></pre></td></tr></table></figure><p>然后可以通过修改 <code>gainNode.gain.value</code> 的值来处理声音的大小。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gainNode.gain.value = <span class="number">0.5</span>; <span class="comment">// 0 静音 1 最大</span></span><br></pre></td></tr></table></figure><h3 id="音乐淡出淡入"><a href="#音乐淡出淡入" class="headerlink" title="音乐淡出淡入"></a>音乐淡出淡入</h3><p>音乐的淡出淡入现在基本上是一个播放器基本的功能而且在游戏中场景的切换也会伴随着背景音乐的改变，在 Web Audio API 的帮助下我们也能很轻易的实现歌曲的淡入淡出功能。</p><p>我们还是使用<code>GainNode</code>去做到这一点。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">CrossfadePlaylistSample.play = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建源和增益器</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createSource</span>(<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> source = context.createBufferSource();</span><br><span class="line">        <span class="keyword">var</span> gainNode = context.createGain ? context.createGain() : context.createGainNode();</span><br><span class="line">        source.buffer = buffer;</span><br><span class="line">        source.connect(gainNode);</span><br><span class="line">        gainNode.connect(context.destination);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            source: source,</span><br><span class="line">            gainNode: gainNode</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> bufferNow = BUFFERS[<span class="keyword">this</span>.playIndex];</span><br><span class="line">    <span class="keyword">var</span> playNow = createSource(bufferNow);</span><br><span class="line">    <span class="keyword">var</span> source = <span class="keyword">this</span>.source = playNow.source;</span><br><span class="line">    <span class="keyword">var</span> gainNode = <span class="keyword">this</span>.gainNode = playNow.gainNode;</span><br><span class="line">    <span class="keyword">var</span> duration = bufferNow.duration; <span class="comment">//持续时间</span></span><br><span class="line">    <span class="keyword">var</span> currTime = context.currentTime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始的时候渐强</span></span><br><span class="line">    gainNode.gain.linearRampToValueAtTime(<span class="number">0</span>, currTime);</span><br><span class="line">    gainNode.gain.linearRampToValueAtTime(<span class="number">1</span>, currTime + <span class="keyword">this</span>.FADE_TIME);</span><br><span class="line">    <span class="comment">//结束的时候减弱</span></span><br><span class="line">    gainNode.gain.linearRampToValueAtTime(<span class="number">1</span>, currTime + duration - <span class="keyword">this</span>.FADE_TIME);</span><br><span class="line">    gainNode.gain.linearRampToValueAtTime(<span class="number">0</span>, currTime + duration);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始播放</span></span><br><span class="line">    source.start ? source.start(<span class="number">0</span>) : source.noteOn(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当歌曲播放完自动切换到下一首。</span></span><br><span class="line">    <span class="keyword">this</span>.timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// console.log(duration - self.FADE_TIME)</span></span><br><span class="line">        self.playIndex === <span class="number">0</span> ? self.playIndex = <span class="number">1</span> : self.playIndex = <span class="number">0</span>;</span><br><span class="line">        self.play();</span><br><span class="line">    &#125;, ((currTime + duration - <span class="keyword">this</span>.FADE_TIME) - currTime) * <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><script async src="//jsfiddle.net/jimwoo/zdh0409o/embed/result/"></script><h3 id="更多的处理器"><a href="#更多的处理器" class="headerlink" title="更多的处理器"></a>更多的处理器</h3><p>Web Audio API 提供了众多的处理器，在本文简单的为大家介绍一下：</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode" target="_blank" rel="noopener"><code>AnalyserNode</code></a> 分析器，可以通过该处理器绘出波形图之类的视图效果。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode" target="_blank" rel="noopener"><code>BiquadFilterNode</code></a> 滤波器，可以通过该处理器对音乐进行降噪、去人声等处理。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/ChannelMergerNode" target="_blank" rel="noopener"><code>ChannelMergerNode</code></a>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/ChannelSplitterNode" target="_blank" rel="noopener"><code>ChannelSplitterNode</code></a> 信道合并\分离处理器，对多个信道进行合并或分离，一般用于对某个信道的音源进行增益处理。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/ConvolverNode" target="_blank" rel="noopener"><code>ConvolverNode</code></a> 混响，主播们都需要。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/DynamicsCompressorNode" target="_blank" rel="noopener"><code>DynamicsCompressorNode</code></a> 削峰处理，一般对音源最响亮的部分进行压缩处理。多用于音乐或游戏多个音频同时播放，以帮助防止在多个声音一起播放和多路复用时可能发生的削波和失真。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/DelayNode" target="_blank" rel="noopener"><code>DelayNode</code></a> 延迟输出。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/OscillatorNode" target="_blank" rel="noopener"><code>OscillatorNode</code></a> 一个恒定的音调，在游戏中一般用来做一些持续性的响声如：愤怒小鸟中里面小鸟飞出去时候的“啊”！</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/PannerNode" target="_blank" rel="noopener"><code>PannerNode</code></a> 空间处理器，可以使音频在多声道中从左到右，从右到左或者在其中一边播放。CS 的脚本声要用到。</p><p>不一一介绍的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaElementAudioSourceNode" target="_blank" rel="noopener"><code>MediaElementAudioSourceNode</code></a> 、<a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamAudioDestinationNode" target="_blank" rel="noopener"><code>MediaStreamAudioDestinationNode</code></a>、[``]</p>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 5.1 预览</title>
    <url>/hack/HTML51.html</url>
    <content><![CDATA[<p>两年发布的HTML5对于web开发社区是一个重大的变革，不仅仅是因为它提供了大量的新特性，还有是因为它是自1999年发布的HTML 4.1 以来最重大的一个更新。你今天仍然能看到很多网站吹嘘自己使用了“时髦”的HTML5。</p><p>很幸运的，我们无需再经历如此长时间来等待下一个版本的迭代。在2015年10月，W3C开始着手起草HTMl5.1的草案以修复现版本HTML5的问题。经过多次迭代之后，在2016年6月更新成为 Candidate Recommendation（候选推荐）状态，同年9月更新为 Proposed Recommendation（推荐标准）状态，最终在11月更新为 <a href="https://www.w3.org/TR/html/" target="_blank" rel="noopener">W3C Recommendation</a> （W3C推荐）。在经历了这些发展后可能我们也发现这一条路十分崎岖，一些最初的 HTML 5.1 特性到最后由于设计上的缺陷和浏览器厂商的不支持导致被放弃了。</p><a id="more"></a><p>即使HTML 5.1仍处于发展期间，但W3C就已经开始着手起草 <a href="https://www.w3.org/TR/html52/" target="_blank" rel="noopener">HTML 5.2 草案</a>并计划在2017年底发布。在此期间，下面将会为大家简单介绍一下HTML 5.1 的新特性和改进。尽管现有的浏览器对HTML 5，1还是缺乏支持，但本文会尽量提供可执行的例子。</p><h2 id="使用menu和menuitems元素创建上下文菜单。"><a href="#使用menu和menuitems元素创建上下文菜单。" class="headerlink" title="使用menu和menuitems元素创建上下文菜单。"></a>使用<code>menu</code>和<code>menuitems</code>元素创建上下文菜单。</h2><p>在5.1的草案介绍当中<code>menu</code>元素有两处不同的改动。<code>context</code>和<code>toolbar</code>。在以前它们是用来扩展原生浏览器的上下文菜单，通常用于右键菜单和自定义菜单组件。在发展过程中，<code>toolbar</code>被放弃了，但是<code>context</code>仍然保留。</p><p>现在可以通过使用<a href="https://www.w3.org/TR/html/interactive-elements.html#the-menu-element" target="_blank" rel="noopener"><code>&lt;menu&gt;</code></a>标签包含一个或多个<a href="https://www.w3.org/TR/html/interactive-elements.html#the-menuitem-element" target="_blank" rel="noopener"><code>&lt;menuitem&gt;</code></a>元素，然后其他元素通过<a href="https://www.w3.org/TR/html/interactive-elements.html#element-attrdef-global-contextmenu" target="_blank" rel="noopener"><code>contextmenu</code></a>属性就行绑定。</p><p>每一个<code>&lt;menuitem&gt;</code>都可以三选一个类型：</p><ul><li><code>checkbox</code> - 允许用户选择或反选一个选项。</li><li><code>command</code> - 允许用户点击后执行一个动作。</li><li><code>radio</code> - 允许用户从一组选项里面选择一个。</li></ul><p>下面是一个基本的例子，但它只能在Firefox 49下工作，Chrome 54 暂时扔不支持。</p><iframe id="cp_embed_bBrvRP" src="//codepen.io/SitePoint/embed/bBrvRP?height=263&amp;theme-id=6441&amp;slug-hash=bBrvRP&amp;default-tab=result&amp;user=SitePoint&amp;embed-version=2&amp;pen-title=HTML%205.1%20menu%20example" scrolling="no" frameborder="0" height="263" allowtransparency="true" allowfullscreen name="CodePen Embed" title="HTML 5.1 menu example" class="cp_embed_iframe" style="width:100%;overflow:hidden"></iframe><p>在可支持的浏览器下，我们应该可以看到如下图：</p><p><img data-src="/images/html51_1.png" alt="html5.1 上下文菜单"></p><h2 id="详情和总结元素"><a href="#详情和总结元素" class="headerlink" title="详情和总结元素"></a>详情和总结元素</h2><p>新的<a href="https://www.w3.org/TR/html/interactive-elements.html#the-details-element" target="_blank" rel="noopener"><code>&lt;details&gt;</code></a>和<a href="https://www.w3.org/TR/html/interactive-elements.html#the-summary-element" target="_blank" rel="noopener"><code>&lt;summary&gt;</code></a>元素可以实现通过点击一个元素来显示或者隐藏额外的信息。我们以往都是通过使用JavaScript来实现的，现在我们在HTML里面使用<code>&lt;details&gt;</code>元素和<code>&lt;summary&gt;</code>元素就能做到这一点。在<code>&lt;details&gt;</code>元素中点击总结即可切换显示其余的内容。</p><p>接下来的例子可以执行在Firefox和Chrome下。</p><iframe id="cp_embed_rWzgzg" src="//codepen.io/SitePoint/embed/rWzgzg?height=395&amp;theme-id=6441&amp;slug-hash=rWzgzg&amp;default-tab=result&amp;user=SitePoint&amp;embed-version=2&amp;pen-title=HTML%205.1%20details%20and%20summary%20demo" scrolling="no" frameborder="0" height="395" allowtransparency="true" allowfullscreen name="CodePen Embed" title="HTML 5.1 details and summary demo" class="cp_embed_iframe" style="width:100%;overflow:hidden"></iframe><p>在可支持的浏览器下，我们应该可以看到如下图：</p><p><img data-src="/images/html51_2.png" alt="html5.1 详情和总结"></p><h2 id="更多的输入框类型：month-week-和-datatime-local"><a href="#更多的输入框类型：month-week-和-datatime-local" class="headerlink" title="更多的输入框类型：month week 和 datatime-local"></a>更多的输入框类型：<code>month</code> <code>week</code> 和 <code>datatime-local</code></h2><p>在强大的输入框类型上再扩展了三种更多的类型：<a href="https://www.w3.org/TR/html/sec-forms.html#month-state-typemonth" target="_blank" rel="noopener"><code>month</code></a>,<a href="https://www.w3.org/TR/html/index.html#contents" target="_blank" rel="noopener"><code>week</code></a>和<a href="https://www.w3.org/TR/html/sec-forms.html#local-date-and-time-state-typedatetimelocal" target="_blank" rel="noopener"><code>datatime-local</code></a>。</p><p>前面两个的类型允许用户选择一个周或者一个月。在Chrome浏览器下它们均被渲染为一个下拉的时间控件用作选择一个今年特指的月份或者周。当利用JavaScript获取它们的值的时候会得到一个字符串，类似：周控件的值为 <code>“2016-W43”</code>,月控件值为<code>&quot;2016-10&quot;</code>。</p><p>起初，5.1草案引入了两个时间类型的输入框：<code>datetime</code> 和 <code>datetime-local</code>，其中差别就是<code>datatime-local</code>总是使用用户的时区，而<code>datetime</code>可以允许用户选择不同的时区。在发展过程中，<code>datetime</code>类型被放弃了只保留了<code>datatime-local</code>类型。<code>datatime-local</code>由两部分组成，日期部分类似<code>week</code>或<code>month</code>输入框，时间部分需要分别输入。</p><iframe id="cp_embed_xRLowg" src="//codepen.io/SitePoint/embed/xRLowg?height=400&amp;theme-id=6441&amp;slug-hash=xRLowg&amp;default-tab=result&amp;user=SitePoint&amp;embed-version=2&amp;pen-title=HTML%205.1%20week%2C%20month%20and%20datetime%20inputs" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen name="CodePen Embed" title="HTML 5.1 week, month and datetime inputs" class="cp_embed_iframe" style="width:100%;overflow:hidden"></iframe><p>在可支持的浏览器下，我们应该可以看到如下图：</p><p><img data-src="/images/html51_3.png" alt="html5.1 日期时间控件"></p><h2 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h2><p>HTML 5.1 引入了几个新特性可以在不适用CSS的情况下实现响应式图片。这些功能每一个都能涵盖所有场景。</p><h3 id="图片属性-srcset"><a href="#图片属性-srcset" class="headerlink" title="图片属性 srcset"></a>图片属性 <code>srcset</code></h3><p>图片的<a href="https://www.w3.org/TR/html/single-page.html#element-attrdef-img-srcset" target="_blank" rel="noopener"><code>srcset</code></a>属性允许开发者在不同像素比的情况下列出可替换的图片源。这个特性可以使浏览器自动去选择对于用户设备最优的图片（由像素比、缩放级别和网络速度决定）。举个例子，你可能会想要当用户在使用小屏幕或者网速较慢的手机的时候提供一张低分辨率的图片。</p><p><code>srcset</code> 属性接受一个以逗号作为分割的带<code>x</code>作为修饰符号的地址列表，这是用于描述各个像素比（物理像素和CSS像素的比率）下合适的图片。一个简单的例子如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/low-res.jpg"</span> <span class="attr">srcset</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">  images/low-res.jpg 1x, </span></span></span><br><span class="line"><span class="tag"><span class="string">  images/high-res.jpg 2x, </span></span></span><br><span class="line"><span class="tag"><span class="string">  images/ultra-high-res.jpg 3x"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，如果用户的设备像素比是1，就会使用<code>low-res.jpg</code>作为显示。如果是2，就会使用<code>high-res.jpg</code> 作为显示。如果是3或更高，<code>ultra-high-res.jpg</code>将会被选中使用。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/low-res.jpg"</span> <span class="attr">srcset</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">  images/low-res.jpg 600w, </span></span></span><br><span class="line"><span class="tag"><span class="string">  images/high-res.jpg 1000w, </span></span></span><br><span class="line"><span class="tag"><span class="string">  images/ultra-high-res.jpg 1400w"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，600px 宽的设备会使用 <code>low-res</code> 图片，1000px 宽使用 <code>high-res</code> , 1400px 或者以上会使用 <code>ultra-high-res</code>。</p><h3 id="图片属性-sizes"><a href="#图片属性-sizes" class="headerlink" title="图片属性 sizes"></a>图片属性 <code>sizes</code></h3><p>开发者可能会想要在不同的屏幕尺寸下显示不同的图片。例如，你可以展示一系列的图片再两列宽度的屏幕上和只有一列的小屏幕上。这可以借助<code>sizes</code>属性来实现。它运行开发者将屏幕的宽度转化为图片分配的空间，然后使用<code>srcset</code>属性选择适合的图片。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/low-res.jpg"</span> <span class="attr">sizes</span>=<span class="string">"(max-width: 40em) 100vw, 50vw"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">srcset</span>=<span class="string">"images/low-res.jpg 600w, </span></span></span><br><span class="line"><span class="tag"><span class="string">  images/high-res.jpg 1000w, </span></span></span><br><span class="line"><span class="tag"><span class="string">  images/ultra-high-res.jpg 1400w"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p><code>sizes</code>属性定义了当视窗的宽度如果大于40em则图片的宽度为视窗的50%，当视窗小于等于40em时则图片宽度为视窗的100%。</p><h3 id="lt-picture-gt"><a href="#lt-picture-gt" class="headerlink" title="&lt;picture&gt;"></a><code>&lt;picture&gt;</code></h3><p>如果认为以上特性还不足够去使图片适应每一个屏幕或者你一个功能需要完完全全显示不同的图片，那么你可以使用<a href="https://www.w3.org/TR/html/single-page.html#elementdef-picture" target="_blank" rel="noopener"><code>&lt;picture&gt;</code></a>。它允许通过开发者用一个<code>&lt;picture&gt;</code>包住<code>&lt;img&gt;</code>和多个子元素<code>&lt;source&gt;</code>来为不同的屏幕定义各种不同源的图片，然后<code>&lt;source&gt;</code>作为图片的URL来进行加载。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">"(max-width: 20em)"</span> <span class="attr">srcset</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">    images/small/low-res.jpg 1x,</span></span></span><br><span class="line"><span class="tag"><span class="string">    images/small/high-res.jpg 2x, </span></span></span><br><span class="line"><span class="tag"><span class="string">    images/small/ultra-high-res.jpg 3x</span></span></span><br><span class="line"><span class="tag"><span class="string">  "</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">"(max-width: 40em)"</span> <span class="attr">srcset</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">    images/large/low-res.jpg 1x,</span></span></span><br><span class="line"><span class="tag"><span class="string">    images/large/high-res.jpg 2x, </span></span></span><br><span class="line"><span class="tag"><span class="string">    images/large/ultra-high-res.jpg 3x</span></span></span><br><span class="line"><span class="tag"><span class="string">  "</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/large/low-res.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想了解更多关于响应式的图片，可以访问 <a href="https://www.sitepoint.com/how-to-build-responsive-images-with-srcset" target="_blank" rel="noopener">How to Build Responsive Images with srcset </a>这篇文章</p><h2 id="验证表单-form-reportValidity"><a href="#验证表单-form-reportValidity" class="headerlink" title="验证表单 form.reportValidity()"></a>验证表单 <code>form.reportValidity()</code></h2><p>HTML5中提供了<a href="https://www.w3.org/TR/html/single-page.html#dom-htmlobjectelement-checkvalidity" target="_blank" rel="noopener"><code>form.checkValidity()</code></a>的方法用于校验一个表单下的所有定义了验证器的输入框，并且返回一个布尔值。新的<code>reportValidity()</code>和这个十分相似，它们同样允许你验证一个表单和获得结果，但是浏览器会另外向用户报告错误。</p><iframe id="cp_embed_eBEwjg" src="//codepen.io/SitePoint/embed/eBEwjg?height=234&amp;theme-id=6441&amp;slug-hash=eBEwjg&amp;default-tab=result&amp;user=SitePoint&amp;embed-version=2&amp;pen-title=HTML%205.1%20report%20validity%20demo" scrolling="no" frameborder="0" height="234" allowtransparency="true" allowfullscreen name="CodePen Embed" title="HTML 5.1 report validity demo" class="cp_embed_iframe" style="width:100%;overflow:hidden"></iframe><p>“First Name”输入框当为空的时候会提醒用户为必填错误。</p><p><img data-src="/images/html51_4.png" alt="HTML5.1 表单验证"></p><h2 id="Frames-的-allowfullscreen"><a href="#Frames-的-allowfullscreen" class="headerlink" title="Frames 的 allowfullscreen"></a>Frames 的 allowfullscreen</h2><p>新的布尔属性<a href="https://www.w3.org/TR/html/single-page.html#element-attrdef-iframe-allowfullscreen" target="_blank" rel="noopener"><code>allowfullscreen</code></a>允许开发者通过调用<a href="https://fullscreen.spec.whatwg.org/#dom-element-requestfullscreen" target="_blank" rel="noopener"><code>requestFullscreen()</code></a>方法来控制他们的内容是否可以在全屏显示。</p><p>##<code>element.forceSpellCheck()</code> 拼写检查</p><p>新的<a href="https://html.spec.whatwg.org/multipage/interaction.html#dom-forcespellcheck" target="_blank" rel="noopener"><code>element.forceSpellCheck()</code></a>方法可以允许你对文本元素进行拼写检查。同时这也是首个这种类型的特性，但暂时没有浏览器支持。或者它至少用于对用户无法直接编辑的元素进行拼写检查。</p><h2 id="那些被放弃的特性"><a href="#那些被放弃的特性" class="headerlink" title="那些被放弃的特性"></a>那些被放弃的特性</h2><p>在第一版的草案中很多特性最终都被放弃，主要是由于缺乏浏览器厂商的支持。下面有一些有趣的想法：</p><h3 id="inert-属性"><a href="#inert-属性" class="headerlink" title="inert 属性"></a><code>inert</code> 属性</h3><p>禁止所有子元素，类似于对每一个子元素添加一个<code>disabled</code>属性。</p><h3 id="dialog-元素"><a href="#dialog-元素" class="headerlink" title="dialog 元素"></a><code>dialog</code> 元素</h3><p><code>&lt;dialog&gt;</code>元素提供了一个弹窗的原生实现，甚至还有一个方便集成的方案——在<code>&lt;dialog&gt;</code>上设置方法属性可以阻止表单提高到服务器，而是关闭对话框并将值返回。</p><iframe id="cp_embed_XNaLOg" src="//codepen.io/SitePoint/embed/XNaLOg?height=300&amp;theme-id=6441&amp;slug-hash=XNaLOg&amp;default-tab=result&amp;user=SitePoint&amp;embed-version=2&amp;pen-title=HTML%20dialog%20element" scrolling="no" frameborder="0" height="300" allowtransparency="true" allowfullscreen name="CodePen Embed" title="HTML dialog element" class="cp_embed_iframe" style="width:100%;overflow:hidden"></iframe><hr><p>转载自：<a href="https://www.sitepoint.com/whats-new-in-html-5-1/" target="_blank" rel="noopener">https://www.sitepoint.com/whats-new-in-html-5-1/</a></p>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>last-of-type 选择器的发现</title>
    <url>/hack/about-last-of-type-selectors.html</url>
    <content><![CDATA[<p><code>:last-of-type</code> 是CSS3新增的选择器，表示指定元素名称位于父元素的字元素列表中的最后一个元素。简而言之就是<strong>最后的一个元素</strong>。在<a href="http://www.w3schools.com/cssref/sel_last-of-type.asp" target="_blank" rel="noopener" title="CSS3 :last-of-type Selector - W3Schools">W3C</a>的说明和<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:last-of-type" target="_blank" rel="noopener" title=":last-of-type - CSS | MDN">MDN</a>的说明页面上都是以元素作为前置选择，但其实<code>:last-of-type</code>也可以作为样式名的伪类选择器。</p><a id="more"></a><h2 id="MDN例子"><a href="#MDN例子" class="headerlink" title="MDN例子"></a>MDN例子</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">em</span><span class="selector-pseudo">:last-of-type</span> &#123;</span><br><span class="line"> <span class="attribute">color</span>: lime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">em</span>&gt;</span>I'm not lime :(<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">strong</span>&gt;</span>I'm not lime :(<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">em</span>&gt;</span>I'm lime :D<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">strong</span>&gt;</span>I'm also not lime :(<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">em</span>&gt;</span>I'm not lime :(<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>I am lime!<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">strong</span>&gt;</span>I'm not lime :(<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">em</span>&gt;</span>I'm lime :D<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>I am also lime!<span class="tag">&lt;/<span class="name">em</span>&gt;</span> <span class="tag">&lt;<span class="name">strike</span>&gt;</span> I'm not lime <span class="tag">&lt;/<span class="name">strike</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">strong</span>&gt;</span>I'm also not lime :(<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><style>.lot-example{margin:0 0 15px;padding:10px;background-color:#eee}.lot-example p:last-child{margin:0}.lot-example p em:last-of-type{color:#0f0}</style><div class="lot-example"><p><em>I'm not lime :(</em> <strong>I'm not lime :(</strong> <em>I'm lime :D</em> <strong>I'm also not lime :(</strong></p><p><em>I'm not lime :(</em> <span><em>I am lime!</em></span> <strong>I'm not lime :(</strong> <em>I'm lime :D</em> <span><em>I am also lime!</em><strike> I'm not lime</strike></span> <strong>I'm also not lime :(</strong></p></div><p>如果按照上面的代码理解，所有<code>p</code>元素下的最后一个<code>em</code>元素的字体将会是<code>lime</code>颜色。</p><h2 id="样式名之后的last-of-type"><a href="#样式名之后的last-of-type" class="headerlink" title="样式名之后的last-of-type"></a>样式名之后的<code>last-of-type</code></h2><p>看完MDN的说法应该也对<code>last-of-type</code>的选择器有了一定的了解，当所有比较官方的例子中都以元素作为前置的选择器那么如果以样式名作为前置选择器会怎么样呢？</p><h3 id="是否有效？"><a href="#是否有效？" class="headerlink" title="是否有效？"></a>是否有效？</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.a</span><span class="selector-pseudo">:last-of-type</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: lime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.b</span><span class="selector-pseudo">:last-of-type</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"a"</span>&gt;</span>我是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"b"</span>&gt;</span>我是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"c"</span>&gt;</span>我是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"b"</span>&gt;</span>我是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"a"</span>&gt;</span>我是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><style>.wrap .a:last-of-type{color:#0f0}.wrap .b:last-of-type{color:red}</style><div class="wrap lot-example"><p class="a">我是一段文字a</p><p class="b">我是一段文字b</p><p class="c">我是一段文字c</p><p class="b">我是一段文字b</p><p class="a">我是一段文字a</p></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看到执行结果可能会有读者感到很疑惑，为何<code>.wrap .a:last-of-type</code>选择符是有效果的而<code>.wrap .b:last-of-type</code>却失效了呢？</p><p>首先可以肯定的是<code>:last-of-type</code>是支持样式名选择器作为前置的，但只是要符合以下条件：</p><p><strong>样式名选择器所选择的元素为当前父元素的子元素列表中的最后一个</strong>，也就是说不但要符合选择器<code>.b</code>并且要符合<code>${element}:last-of-type</code>。在</p><blockquote><p>针对上面HTML的结构来生成一个表达式的话，<br><code>.wrap .b:last-of-type</code> === <code>.wrap .b &amp;&amp; p:last-of-type</code>。</p></blockquote><p>如果把上面的HTMl代码改成如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"a"</span>&gt;</span>我是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"b"</span>&gt;</span>我是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"c"</span>&gt;</span>我是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"b"</span>&gt;</span>我是一段文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"a"</span>&gt;</span>我是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="wrap lot-example"><p class="a">我是一段文字a</p><p class="b">我是一段文字b</p><p class="c">我是一段文字c</p><div class="b">我是一段文字b</div><p class="a">我是一段文字a</p></div><p>按上述修改后，最后一个<code>.b</code>把元素修改成<code>div</code>则符合了<code>${element}:last-of-type</code>这一个要求，所以就生效了。</p>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移至Hexo，并且开源hexo-cdnify</title>
    <url>/joke/blog-with-hexo-and-publish-hexo-cdnify.html</url>
    <content><![CDATA[<p>从最初第一次使用Wordpress搭建博客的时候便深深喜欢这套开源的博客系统，更是有一段时间在研究Wordpress的API文档也曾经做了几套主题。越到往后WP的系统功能更加丰富但同时也十分耗服务器的资源和运行相对较慢。所以在今年一直寻思换一个更加轻量的博客，专注于写东西和分享。</p><a id="more"></a><h1 id="选择使用Hexo"><a href="#选择使用Hexo" class="headerlink" title="选择使用Hexo"></a>选择使用Hexo</h1><p>其实使用Hexo作为新的博客程序主要有两大原因：</p><ul><li>绝对的轻量化。发布文件为纯静态、配置都通过配置文件生成、无撰写后台以markdown文件作为承载。</li><li>以NodeJS作为开发语言。主要由于熟识JavaScript，对于开发、改造等都十分方便快捷。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>hexo 的安装相当简单，一切都是基于<code>npm install</code>实现安装，如果本身对NodeJS熟识的话基本无需多费神。第一步是需要安装<code>hexo-cli</code>，然后创建项目再初始化即可完成。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br></pre></td></tr></table></figure><blockquote><p>其实在初始化的时候已经一同进行了<code>npm install</code>，所以官方教程中的这一步可以忽略。</p></blockquote><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>配置文件的修改、新建文章等其实官方都已经有中文文档而且十分详尽在此我也不重复了。其中部署这一块大多数人选择了部署到Github Pages上，由于阿里云还有一年才到期所以我选择了同时部署到两个不同的地方上。</p><h3 id="部署到-Github-Pages"><a href="#部署到-Github-Pages" class="headerlink" title="部署到 Github Pages"></a>部署到 Github Pages</h3><blockquote><p>部署到Github Pages需要注意的是在创建repo的时候repo的名字很重要。<br><code>${username}.github.io</code> 的项目名字，生成Github pages的时候是以<code>master</code>分支作为Source的。而其他名称则以<code>gh-pages</code>分支作为Source的。所以在创建仓库的时候必须注意这两点。</p></blockquote><p><a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener" title="hexo部署教程">部署教程</a>中其实已经很详细的介绍了所有方式，包括git、ftp、rsync等方式。但需要主要的是由于Github Pages的一个改动使得不再支持 <code>/vendors/*</code> 下的所有静态文件，会导致大部分的样式、JS文件都会出现404 Not Found错误。解决办法也相当简单就是在 source 文件夹下创建一个 <code>.nojekyll</code>的空文件即可。</p><p><code>touch source/.nojekyll</code></p><h3 id="部署到阿里云"><a href="#部署到阿里云" class="headerlink" title="部署到阿里云"></a>部署到阿里云</h3><p>部署到阿里云可能有些人会选择使用FTPsync的方式，但是由于我也把源代码托管在Github上也就是说我的配置文件是“开源”的，所以FTP的密码就很容易暴露无遗。所以同步到阿里云我使用的方式是rsync。</p><p>首先在阿里云设置ssh免登录的方式免去输入密码，然后安装rsync即可。这样一来可以实时同步也可以免去密码被暴露的风险。</p><h1 id="开源插件-hexo-cdnify"><a href="#开源插件-hexo-cdnify" class="headerlink" title="开源插件 hexo-cdnify"></a>开源插件 hexo-cdnify</h1><p>这个插件其实就是在编译过程中把本地的所有静态文件指向cdn上。</p><p><code>&lt;img src=&quot;/uploads/hi.jpg&quot; /&gt;</code> 编译后 <code>&lt;img src=&quot;//cdn/uploads/hi.jpg&quot; /&gt;</code></p><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>在使用WP的时候便已经习惯把一些图片、CSS文件、JS文件都存放到七牛云上，所以很习惯的在搭建完hexo之后就是必须利用cdn进行优化，但是hexo的七牛插件需要一堆的配置并且需要密钥，作为利用github托管源的最不想看到的就是需要把一些敏感信息填写到配置文件上，所以决定自己动手完成这个插件。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>由于这个并非主动上传，只是利用了七牛的镜像功能所以需要在七牛上设置镜像功能和准确的路径。</p><p><code>npm install hexo-cdnify --save</code>，安装完之后修改 hexo 的配置文件，添加如下配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cdn:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">base:</span> <span class="string">//cdn.com</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="string">'img[data-orign]()'</span><span class="string">:</span>  <span class="string">data-orign</span></span><br></pre></td></tr></table></figure><p><code>base</code> CDN的域名或者镜像链接。</p><p><code>tags</code> 需要替换的标签和元素的Map对象。<code>&#39;img[data-orign]&#39;: data-orign</code>即：寻找含<code>data-orign</code>属性的<code>img</code>标签，并且替换其<code>data-orign</code>属性的地址为CDN。<code>tags</code>默认已支持下列元素和属性：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">"____"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"____"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span> <span class="attr">href</span>=<span class="string">"____"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"____"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">href</span>=<span class="string">"____"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"____"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"____"</span>\&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"____"</span>\&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>由于在生成静态文件之前不需要替换CDN，所以只有在<code>hexo g</code>活着<code>hexo d -g</code>时候才会进行替换，而<code>hexo s</code> 或<code>hexo server</code> 都是会忽略掉的。</p>]]></content>
      <categories>
        <category>Joke</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>React 那些破事儿</title>
    <url>/hack/about-react.html</url>
    <content><![CDATA[<p>react、vue、angularjs作为这两年在前端界里面最为红红火火的几款框架，几乎每一次的技术交流、群里的讨论都少不了它们的相关内容。作为前端发开者即使并没有真正的用在开发上但至少也对这几款框架有所了解。</p><a id="more"></a><h1 id="最初的接触"><a href="#最初的接触" class="headerlink" title="最初的接触"></a>最初的接触</h1><p>作为当前最为火热的框架总少不了对比与骂声，小编所坚持的仍是“只有最合适，没有最好”的原则。当小编了解过刚才提到过的几款框架后，其实都比较清晰最适合他们的应用场景了：<strong>交互繁杂、UI可高度重复使用。对于这种场景无非就是各种管理平台，如单页面应用、用户级的管理后台。</strong></p><p>这一次小编接到一个新的任务：移动端的内容审核后台。在分析需求时觉得十分贴合「交互繁杂、UI可高度重复使用」的条件，便决定了使用 React 作为这一次前端开发的框架，接口便是使用 Restful 方式。</p><h2 id="官网入门教程过于模糊？"><a href="#官网入门教程过于模糊？" class="headerlink" title="官网入门教程过于模糊？"></a>官网入门教程过于模糊？</h2><p>第一次接触显然便是从官网教程入手，当看完首页上所有的简单例子仍是难以理解的不在少数。其实官网首页的教程很好的突出了在 React 里面几个重要的元素：<strong>React.createClass、render()、props、state、refs、Event System</strong>。当使用Raect编写应用的时候，少不了都要去触碰这几个元素或许在看教程之前可以先了解一下这些元素都干了什么权当是预习。</p><p><strong>React.createClass</strong></p><p>在React的框架里，每一个元素、插件都以<strong>Component（组件）</strong>的形式存在。createClass 的方法即是创建一个 React 的 Component，可以覆写声明周期的所有方法、初始化的数据返回、上下文的返回等一些高级应用的技巧。</p><p><strong>render</strong></p><p>每一个Component（接下来都叫组件）都应当覆写render方法，该方法返回的是组件的试图也就是我们平时编写的HTML代码。最值得称道的是 react 有一套在js里面写HTML的规范：JSX。JSX 和一般的 HTML 差异并不大，但仍需一些注意的地方：样式类名需要改成 className，不能直接写HTML代码等。</p><p><strong>props</strong></p><p>每一个组件都有其Props（属性），其属性一般由其父组件传递并且自身不做改变的所以一般用来存放相对静态的数据。</p><p><strong>state</strong></p><p>和属性一样是数据模型，但State（状态）仅仅是为了互动性。<strong>React是用两种数据模型的，Props是作为该组件的基础数据，而State则仅仅是为了互动而产生的数据改动。</strong></p><p>state和props是最容易混淆的一个地方，因为两者几乎是一样但在React编程思想中，对于两者有明确的区分。下面举个例子或许可以让大家更清晰的了解两者的区分：</p><blockquote><p>一个用户的信息如nickname、gender、accountId等应该存放在props中。<br>而当这个用户修改头像时，isShowCropImgDialog（是否显示裁剪图片的弹窗）这种状态属性的改变应当存放在state中。（看到这里没有接触过React的人或许迷糊了，以往这种弹窗不是都是直接在js代码中一个<code>xxx.show()</code>吗?请耐心看下去，下面会有解释。）</p></blockquote><p>想了解更多可阅读：<a href="https://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html" target="_blank" rel="noopener">Interactivity and Dynamic UIs</a></p><p><strong>refs</strong></p><p>当你编写完JSX、render()之后想获取回某些元素实例的时候就需要用到refs了。如需要获取某个input的值，react并不建议直接通过获取获取DOM并获取这个值，而是通过refs的方式去获取。</p><p>说到这个点上，React 编程思想中有一个很明确的要求：<strong>万不得已，不要直接对DOM进行操作</strong>，众所周知React为了效率是采用了虚拟DOM，这也是为什么不能直接对dialog进行<code>.show()</code>的原因。</p><p><a href="https://facebook.github.io/react/docs/more-about-refs.html" target="_blank" rel="noopener">more-about-refs</a></p><p>﻿</p><p><strong>Event System</strong></p><p>几乎所有事件控制都不需要额外的绑定，而是在JSX上进行的绑定。详细请看：<a href="https://facebook.github.io/react/docs/events.html" target="_blank" rel="noopener">Event System</a></p><h1 id="下次"><a href="#下次" class="headerlink" title="下次"></a>下次</h1><p>接下来下一篇文章或许还是说react，然后说说关于如何快速理解 react 的开发模式，redux 的一些运用。其实react并不难，但redux还是需要去理解一下。</p>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>函数表达式和函数声明</title>
    <url>/hack/function-expressions-and-function-declarations.html</url>
    <content><![CDATA[<p>众所周知在JavaScritp中有两种方法来创建函数，但作为有着悠远历史的函数声明逐渐被函数表达式所取代。函数声明和函数表达式的定义是相当混乱的，其中ECMA只定义了函数声明必须有一个函数名以及函数表达式可以省略他们。但即使这样两种方法之间各自都有着自己独有的优势，在不同的情景下都有其存在的必要。</p><a id="more"></a><h2 id="区分函数声明和函数表达式"><a href="#区分函数声明和函数表达式" class="headerlink" title="区分函数声明和函数表达式"></a>区分函数声明和函数表达式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">declaration</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数表达式</span></span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span> <span class="title">expressions</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数表达式</span></span><br><span class="line"><span class="keyword">var</span> expressions = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">declaration</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>看了以上的代码是不是感觉到十分疑惑，他们之间看上去完全一样。那么他们之间又是怎么定义函数声明和函数表达式的呢？在此看来ECMAScript是基于上下文来进行区分的。如果<code>function foo(){}</code>作为赋值表达式的一部分那么这段代码则被认为是<strong>函数表达式</strong>，同理当<code>function foo(){}</code>处于函数内部或程序本身的最顶层则被认为是<strong>函数声明</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;); <span class="comment">//函数表达式</span></span><br></pre></td></tr></table></figure><p>其中使用<code>()</code>括号括起的代码构成一个上下文的分组操作，里面包含赋值表达式。</p><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>函数声明的方式中有一个很重要的特性就是：函数声明提升（function declaration hoisting）。函数声明提升意味着在执行代码之前，所有函数声明都会被优先解释声明。也就是说函数声明可以放在最后定义也无所谓。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成功执行</span></span><br><span class="line">inwoo();</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明可以放在代码最后，但必须不在其他代码块下。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inwoo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免有条件创建函数声明"><a href="#避免有条件创建函数声明" class="headerlink" title="避免有条件创建函数声明"></a>避免有条件创建函数声明</h3><p>函数是可以被有条件地被声明的，也就是意味着：在一个<code>IF</code>判断语句里面可以嵌套着函数声明。但有的浏览器会将这种声明视为无条件的声明。无论判断是<code>true</code>或<code>false</code>，函数都会被声明。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 千万别这么做！！</span></span><br><span class="line"><span class="comment">// 某些浏览器会把函数foo声明为"first"</span></span><br><span class="line"><span class="comment">// 也有些浏览器会声明为"second"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'first'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'second'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替方式，应该采用函数表达式。</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'first'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'second'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><blockquote><p>函数声明理应只在程序本身和函数内部的顶级，在语法上他们不应出现在<code>{}</code>代码块内（函数内部除外），其中包括<code>if</code>、<code>for</code>、<code>while</code>这些方法内。因为这些代码块内只是包含语句，而非源元素（即非顶级域）。</p></blockquote><blockquote><p>如果需要更多关于函数声明的资料可以访问 <a href="http://kangax.github.io/nfe/#function-statements" target="_blank" rel="noopener">http://kangax.github.io/nfe/#function-statements</a>，文中介绍了更多别开生面的声明方法和各个版本浏览器的一些Bug。</p></blockquote><h2 id="函数表达式的好处"><a href="#函数表达式的好处" class="headerlink" title="函数表达式的好处"></a>函数表达式的好处</h2><p>根据使用习惯，函数表达式比函数声明更有优势。以下是函数表达式的一些实用场景。</p><ul><li>闭包</li><li>作为其他函数的参数</li><li>作为立即调用表达式(IIFE)</li></ul><h3 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h3><p>当你想在执行一个函数前传递一些参数给该函数时，闭包此时就显得十分有用了。一个最好的例子就是当你想循环遍历一个节点列表时，闭包可以使得在函数执行的情况下保留其它参数如索引（index），以不至于丢失不见。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tabsHandler</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">tabClickEvent</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">         <span class="comment">//这时候index可以作为内部参数使用。</span></span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> tabs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.tab'</span>),</span><br><span class="line">     i;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tabs.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">     tabs[index].onclick = tabsHandler(i);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该事件处理会在稍后执行（点击事件），所以这里我们需要一个闭包来保留循环过程中的参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad code</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; list.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#item'</span> + i).onclick = <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 当方法执行时，无论点击哪个元素 i 都是 list.length。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.item'</span>),</span><br><span class="line">    i,</span><br><span class="line">    doSomething = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">       <span class="comment">//如果使用这个方法，则没办法获得i在循环中的值。</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; list.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    item[i].onclick = doSomething;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// good code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list = [<span class="string">'item1'</span>, <span class="string">'item2'</span>, <span class="string">'item3'</span>],</span><br><span class="line">    i,</span><br><span class="line">    doSomethingHandler = <span class="function"><span class="keyword">function</span>(<span class="params">itemIndex</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        	<span class="comment">//此时的索引作为参数itemIdenx保存在内部函数当中，</span></span><br><span class="line">        	<span class="comment">//所以调用时并不会存在以上问题。</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Doing something with '</span> + list[itemIndex]);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; list.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    list[i].onclick = doSomethingHandler(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面两个<strong>Bad code</strong>的例子索引(index)的值都不是循环过程中产生的值，所以这里的解决办法是我们将循环过程时的索引传递到一个外部的函数以便传递到一个内部函数（此时作为内部函数该值不会再改变）。</p><h3 id="作为参数传递"><a href="#作为参数传递" class="headerlink" title="作为参数传递"></a>作为参数传递</h3><p>函数表达式可以作为参数传递到一个另一个函数中，而无需一个临时变量。最典型的例子就是jQuery的ready方法的匿名函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>同时我们在使用<code>forEach</code>、<code>map</code>、<code>reduce</code>等方法时，函数表达式可以用来处理列表中每个对象，而且我们可以为函数命名或者采用匿名函数。为函数命名有一个好处就是可以清晰的知道该函数是处理什么样的业务。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> productIds = [<span class="string">'12356'</span>, <span class="string">'13771'</span>, <span class="string">'15492'</span>];</span><br><span class="line"></span><br><span class="line">productIds.forEach(<span class="function"><span class="keyword">function</span> <span class="title">showProduct</span>(<span class="params">productId</span>) </span>&#123;</span><br><span class="line">   alert(productId);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="立即调用的函数表达式（IIFE）"><a href="#立即调用的函数表达式（IIFE）" class="headerlink" title="立即调用的函数表达式（IIFE）"></a>立即调用的函数表达式（IIFE）</h3><p>IIFE可以很好的帮助我们在编写JavaScritp代码时避免函数、变量产生全局的污染或冲突。所有的属性都被限制在一个匿名函数内进行定义。</p><p>一个最简单的IFFE</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//code</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>当需要实现模块化的时候，IFFE可帮助简单地实现高可维护的代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> privateMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'A private method'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        someMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'A public method'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        anotherMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Another public method'</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        someMethod: someMethod,</span><br><span class="line">        anotherMethod: anotherMethod</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>除此之外，IFFE还可以实现对代码的优化。如：我们需要判断浏览器内核获得一个特有的对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getSpecObj = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isWebkit = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(isWebkit)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//code</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//code</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上内容介绍，清晰了解到函数表达式和函数声明之间的差异，并且函数表达式能使更加清晰、简单并且维护性更高。函数表达式已经被广泛使用到各个库或代码片段当中。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.sitepoint.com/function-expressions-vs-declarations/" target="_blank" rel="noopener">http://www.sitepoint.com/function-expressions-vs-declarations/</a></li><li><a href="http://kangax.github.io/nfe/#function-statements" target="_blank" rel="noopener">http://kangax.github.io/nfe/#function-statements</a></li></ul>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>混合应用的JavaScript Bridge（三）</title>
    <url>/hack/hybrid-app-javascript-bridge-3.html</url>
    <content><![CDATA[<p>上一篇说到如何设计一个统一的跨平台的实现方式，那么今天就详细的说说各个平台是如何实现的自己的私有的代码。在开始之前可以回顾下第一篇的文章，通过分析两平台之间实现的差异可以更容易理解本篇文章。</p><a id="more"></a><h3 id="Android-平台下发送到客户端的实现"><a href="#Android-平台下发送到客户端的实现" class="headerlink" title="Android 平台下发送到客户端的实现"></a>Android 平台下发送到客户端的实现</h3><p>其实根据第一篇文章中的介绍，Android实现起来并没有什么难度。因为Android既可以对window注入，也可以调用前端的js方法。所以在实际的编码过程中并没有太多复杂的东西。只要客户端对WEBView注入方法<code>AndroidBridge</code>便可以了，但需要<strong>注意</strong>的是，在调用<code>AndroidBridge</code>的时候必须采用call的方法，并且把调用对象（第一个参数）设置为AndroidBridge。不然在某些android版本上会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于回调函数我们暂时不考虑</span></span><br><span class="line">send:<span class="function"><span class="keyword">function</span>(<span class="params">api,params,successCallback,failCallback</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> callbackId = gCallbackId();</span><br><span class="line">   <span class="keyword">if</span>(isAndroid)&#123;</span><br><span class="line">      AndroidBridge.call(AndroidBridge,api,params,callbackId); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IOS-平台下发送到客户端的实现"><a href="#IOS-平台下发送到客户端的实现" class="headerlink" title="IOS 平台下发送到客户端的实现"></a>IOS 平台下发送到客户端的实现</h3><p>由于ios的平台限制比Andoird的复杂得多，实现起来也难得多。由于ios没有办法注入方法到前端当中（只针对uiwebview）所以我们在前端只能通过改变url来通知客户端应该来获取数据了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">iosSendMsgArray:[], <span class="comment">//ios纪录接口请求</span></span><br><span class="line">frame:<span class="literal">null</span>,</span><br><span class="line">send:<span class="function"><span class="keyword">function</span>(<span class="params">api,params,successCallback,failCallback</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> callbackId = gCallbackId();</span><br><span class="line">   <span class="keyword">if</span>(isAndroid)&#123;</span><br><span class="line">      </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   	 <span class="keyword">this</span>._iosSend(api,params,callbackId);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br><span class="line">_iosSend:<span class="function"><span class="keyword">function</span>(<span class="params">api,params,callbackId</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> frame = <span class="keyword">this</span>.frame;</span><br><span class="line">	<span class="keyword">if</span>(!frame)&#123;</span><br><span class="line">		<span class="keyword">this</span>.frame= <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">		frame = <span class="keyword">this</span>.frame;</span><br><span class="line">    	frame.style.display = <span class="string">'none'</span>;</span><br><span class="line">    	<span class="built_in">document</span>.documentElement.appendChild(frame);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.iosSendMsgArray.push(&#123;</span><br><span class="line">		api:api,</span><br><span class="line">		params:params,</span><br><span class="line">		callbackId:callbackId</span><br><span class="line">	&#125;);</span><br><span class="line">	frame.src = <span class="string">'inhu://send'</span>;  </span><br><span class="line">	<span class="comment">//以上代码可以优化，每隔一段时间再去发起一次通知不必每次发起。</span></span><br><span class="line">	<span class="comment">//但这里我们还是以最简单的方式来展示。不做多余的代码。</span></span><br><span class="line">&#125;,</span><br><span class="line">IOSGetMsg:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> resultStr = <span class="keyword">this</span>.iosSendMsgArray.toString();</span><br><span class="line">	<span class="keyword">this</span>.iosSendMsgArray.length=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> resultStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码，我们可以知道当前端要调用后台提供的借口时<code>send()</code>，如果是IOS的话我们会先暂时存放到一个数组里面然后修改iFrame的链接以实现通知IOS，IOS接到通知后便调用前端的<code>inhuBridge.IOSGetMsg</code>获得一组数据。然后IOS去解释字符串便可。</p><h3 id="回调的实现"><a href="#回调的实现" class="headerlink" title="回调的实现"></a>回调的实现</h3><p>我们简单的实现了发送消息到客户端的代码，当然这里只是简单的实现方式而已可能在实际使用过程中也存在一些缺陷。但这理暂时不做讨论，我们只关心如何客户端和前端是如何通讯的。</p><p>我们上篇文章说过要有一个<code>CallBackId</code>，我们每发起一次发送请求之前都需要把成功回调和失败回调缓存起来，并且把callBackId作为信息的一部分发送到客户端而客户端发起返回数据时同时也要把CallBackId作为参数返回并从缓存中取出相关的回调。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">callBackCache:&#123;&#125;,</span><br><span class="line">send:<span class="function"><span class="keyword">function</span>(<span class="params">api,params,successCallback,failCallback</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> callbackId = gCallbackId();</span><br><span class="line">   <span class="keyword">this</span>.callBackCache[callbackId] = <span class="function"><span class="keyword">function</span>(<span class="params">_resultData</span>)</span>&#123;</span><br><span class="line">   		<span class="keyword">if</span>(_resultData.status)&#123;</span><br><span class="line">   			successCallback(_resultData);</span><br><span class="line">   		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   			failCallback(_resultData);</span><br><span class="line">   		&#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(isAndroid)&#123;</span><br><span class="line">      </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br><span class="line">receive:<span class="function"><span class="keyword">function</span>(<span class="params">respond</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.callBackCache[respond.callbackId](respond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于IOS和Android之间如何实现客户端调用前端的方法，前篇文章已经说过了。这里就不再说了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章算不上完整的解决方案，只是提供了大家一个思路方案仅此而已。为了简单明了的用代码展示出如何实现的所以代码过程中忽略了很多应有的判断和方式。</p><p>根据上面的思路方式可以延伸出更多的功能，如会话模式、事件通知等。</p>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>混合应用的JavaScript Bridge（二）</title>
    <url>/hack/hybrid-app-javascript-bridge-2.html</url>
    <content><![CDATA[<p>通过<a href="http://inhu.net/hybrid-app-javascript-bridge-1.html" target="_blank" rel="noopener" title="混合应用的JavaScript Bridge（一）">《混合应用的JavaScript Bridge（一）》</a>大家应该对 IOS 和 Android 平台如何实现与 JavaScript 通讯有了简单的了解，并且也说到了两平台之间的差异。既然我们要实现一个跨平台的、统一的 JSSDK 就需要把它们之间的差异抹平，实现接口统一。</p><a id="more"></a><h2>统一接口</h2><p>首先第一步要做的事我们必须先规定好对外的接口，也就是我们所说的API。我们需要定义两个简单的接口：<strong>发送、接收</strong>。发送，就是从JS发送到Native上，接收则反之。</p><pre class="decode:true lang:javascript"><code>window.inhuBridge = {
    /**
     * 发送信息到Native
     * 
     * @param  {String} api  原生的api
     * @param  {Object} params 调用参数
     * @param {Function} successCallback 回调
     * @param {Function} failCallback 失败的回调
     */
    send:function(api,params,successCallback,failCallback){

    },
    /**
     * 接收信息从Native
     * 
     * @param  {Object} respond 调用原生api后返回的对象
     * @param {Number} respond.status 0/1，调用成功或失败。
     * @param {String} respond.message 失败的信息
     * @param {String} respond.callbackId 会话ID
     * @param {Object} respond.data 成功后返回的数据。
     */
    receive:function(respond){

    }
}
</code></pre><h2>原生API</h2><p>从以上的代码，我们定义了最简单最直白最明了的对外接口。当然仅仅靠这些注释还是会模糊不清，特别是发送信息中的<code>api</code>更不知从何而来。</p><p>首先我们需要搞清楚的是，实现这个bridge就是为了能让webview获得由原生支持的功能，例如调起分享的功能、录制音频视频等，所以我们不仅仅需要在<strong>JavaScript上面做接口定义，我们还需要在原生部分实现我们想要的功能，如分享到xx</strong>。</p><p>原生的api我们简单地用以下字符串的方式作为定义：</p><pre><code>Module[:Channel]:Action

// share:weibo:config  配置微博分享内容
// share:showMenu 显示分享菜单
</code></pre><p><em>当然，如果需要更复杂的业务也可以通过自己定义相关格式。</em></p><h2>CallbackId</h2><p>接下来我们要说的是回调。当成功请求了原生里预先定以好的接口后会应答会得到一个响应，如分享是否成功、地理位置的数据等，但由于JavaScript和原生相互调用都是通过注入、修改URL等方式，无论是this还是caller都是没办法和调用的方法关联起来也就是说没办法获取到调用时设置好的回调方法。</p><p>那唯一的办法就只剩下使用唯一标识的方法，<strong>callbackId</strong>就是唯一的标识。当我们调用原生方法的时候我们先生成一个 callbackId 然后，将回调方法一callbackId作为key缓存到一个对象中，然后连同 callbackId 作为参数之一调用原生方法，当原生方法需要反馈到JavaScript的时候把callbackId也传回去，当JavaScript接到一个从原生返回的反馈的时候通过callbackId调起相对应的回调方法。</p><h2>生成callbackId</h2><p>生成callbackId其中必须保证每一个callbackId都只是对应一次的调用而且是唯一的，由于文章篇幅的关系什么uuid、guid的就不考虑了，以最简单的递增方式来说清楚就好了</p><pre class="decode:true lang:javascript"><code>var gCallbackId = (function(){
    var _id = 1;
    return function(){
        return _id++;
    }
})()
</code></pre><p>上面使用了闭包是为了防止<code>_id</code>受外部的脏代码影响。关于闭包的知识点大家可以从网上搜索一下。</p><p>这一篇就大致说了我们先要规范好、统一好接口，那接下来我们说说Android的实现，最后再说IOS的实现方式。</p>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>混合应用的JavaScript Bridge（一）</title>
    <url>/hack/hybrid-app-javascript-bridge-1.html</url>
    <content><![CDATA[<p>在移动互联快速发展的今天，越来越多的应用采用Hybrid（混合模式）的开发方式。所谓的混合模式就是采用原生应用和网页应用相结合，我们熟知的<strong>手机淘宝</strong>就是采用了混合模式的应用，而<strong>微信甚至提供了JSSDK</strong>作为对公众号开发WEB应用的支持和扩展。</p><p>混合模式开发最大的好处就是能快速迭代并且跨平台。快速迭代是因为所有视图和业务层面的代码都将由WEB去进行处理，对于节日活动、更换风格、修改逻辑等非核心功能的修改只需更新WEB的线上代码而无需对原生代码进行修改，这样的方式无需用户对手机上的应用进行下载更新便可达到线上更新。跨平台也是显而易见的优势，主流移动设备主要是IOS和Android两大平台，对HTML5都有着很好的支持。</p><p>那今天主要以前端的视角来带大家看一下如何从零开始实现原生应用和JavaScript的通讯。</p><a id="more"></a><h2>平台之分</h2><p>当今主流的移动设备平台主要分为 <em>IOS</em> 和 <em>Android</em>（WinPhone市场占有率低到只能忽略），由于它们之间的架构差异导致了对 WebView 进行通讯的方式也不一样，而我们需要实现的是一个跨平台的通用的“接口”，所以在开始之前我们先要梳理一下它们平台之间的差异化。</p><h4>Android</h4><p>Android 平台下可对 WebView 添加 JavaScript 对象，在创建一个WebView 之后可调用 [addJavascriptInterface](<a href="http://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface" target="_blank" rel="noopener">http://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface</a>(java.lang.Object, java.lang.String)) 插入一个 JavaScript 的对象并且绑定到原生的对象上。</p><blockquote>Injects the supplied Java object into this WebView. The object is injected into the JavaScript context of the main frame, using the supplied name. This allows the Java object's methods to be accessed from JavaScript.</blockquote><pre class="decode:true lang:java"><code> class JsObject {
    @JavascriptInterface
    public String toString() { return "injectedObject"; }
 }
 webView.addJavascriptInterface(new JsObject(), "injectedObject");
 webView.loadData("", "text/html", null);
 webView.loadUrl("javascript:alert(injectedObject.toString())");
</code></pre><p>上面的官方例子中将 Java 对象 JsObject 通过 <code>addJavascriptInterface (Object object, String name)</code> 的方法以 <code>injectedObject</code> 的名字插入到 WebView 的 JavaScript 上下文中，即 <code>window.injectedObject</code>。</p><p>Android 提供了 <code>addJavascriptInterface</code> 方法，显然对于 JavaScript 发送信息到原生应用上实现起来就更简单了。那么原生应用发送信息到 JavaScript 则通过更改url实现。</p><pre class="decode:true lang:java"><code><br>webView.loadUrl("javascript:alert(injectedObject.toString())");
</code></pre><h4>IOS</h4><p>IOS 相比 Android 则显得没那么友好，需要通过对 <strong>UrlScheme</strong> 监听以达到获取心的消息（来自WebView）通知的效果。</p><p>原生应用设置好监听的 UrlScheme 后，当 WebView 需要发送消息的时候则请求访问约定的链接，原生应用利用<code>stringByEvaluatingJavaScriptFromString</code>或者<code>evaluateJavascript</code>获取详细信息并且进行处理。<strong>IOS平台与Android平台实现通讯的最大区别在于，Android 被动接收由 JavaScript 推送过来的内容，但 IOS 上则是通过监听由 WebView 发起一个指定URL的请求后，主动执行 JavaScript 的方法并且获取返回值</strong>。</p><p>需要注意的是 UIWebView 使用的是<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIWebView_Class/#//apple_ref/occ/instm/UIWebView/stringByEvaluatingJavaScriptFromString:" target="_blank" rel="noopener">stringByEvaluatingJavaScriptFromString</a>，而 WKWebView 使用的是<a href="https://developer.apple.com/library/ios/documentation/WebKit/Reference/WKWebView_Ref/index.html#//apple_ref/occ/instm/WKWebView/evaluateJavaScript:completionHandler:" target="_blank" rel="noopener">evaluateJavascript</a>。</p><pre class="decode:true lang:object-c"><code>(void)evaluateJavaScript:(NSString *)javaScriptString
         completionHandler:(void (^)(id,
                                     NSError *error))completionHandler

- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script
</code></pre><p><em>其中官方文档中说明IOS8之后WKWebView将会替代UIWebView.</em></p><h2>总结</h2><p>通过对以上两个平台如何实现与JavaScript通讯的了解后，发现他们之间的实现方式和通讯方式天差地别，所以我们要实现一个跨平台的通讯方式只有从 JavaScript 上面入手。下一篇文章将介绍如何设计一个跨平台的 JSSDK。</p>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>说一说BFC</title>
    <url>/hack/what-is-bfc.html</url>
    <content><![CDATA[<p>对于一个前端来说BFC是一个必须知道的知识点至少笔者是这么觉得的，因为在很多知识点上都涉及了BFC如：清除浮动、间距折叠等问题的解决办法其实都是和BFC有着千丝万缕的关系。</p><a id="more"></a><h2 id="W3C对BFC的解释"><a href="#W3C对BFC的解释" class="headerlink" title="W3C对BFC的解释"></a>W3C对BFC的解释</h2><p><a href="http://www.w3.org/TR/CSS2/visuren.html#block-formatting" target="_blank" rel="noopener">http://www.w3.org/TR/CSS2/visuren.html#block-formatting</a></p><blockquote><p>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。</p><p>在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。</p><p>在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。</p></blockquote><p><img data-src="http://inhu.qiniudn.com/BFC-0.jpg" alt="http://inhu.qiniudn.com/BFC-0.jpg"></p><h2 id="通俗讲解"><a href="#通俗讲解" class="headerlink" title="通俗讲解"></a>通俗讲解</h2><p>首先明确一点BFC并非技术或者方法，而是一个概念一个规范。那个所谓的BFC我们该怎么更简单容易地理解它呢？我们可以把BFC理解成为网页布局中独立出一个布局环境，不受外界任何影响。也就是在BFC内的元素是不受外界影响。由于这里涉及到了关于网页布局的一些问题，那么我们先简单熟识一下网页的几个布局格式。</p><p>但如果嫌文章过长，那么总结一句就是：** 另起一行，重新布局**！</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p><strong>常规流 Normal Flow</strong></p><p>在普通流中，所有块级元素会按照 HTML 中编码的先后顺序由上至下。而行内元素由左至右横向排列直到该行被占满然后换行。</p><p><strong>浮动 Floats</strong></p><p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p><p><strong>绝对定位</strong></p><p>在绝对定位布局中，元素会整体脱离常规流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p><p><img data-src="http://inhu.qiniudn.com/BFC-1.jpg" alt="http://inhu.qiniudn.com/BFC-1.jpg"></p><p>看完了关于网页的布局之后，我们回到BFC这个话题上。认识并且熟识BFC是对于前端在做布局上面是必要的，很多前端或者非前端因为不认识BFC导致了他们所谓莫名其妙的问题。其实BFC是解决垂直间距折叠、清除浮动这些常见问题的根源。</p><h3 id="如何触发BFC"><a href="#如何触发BFC" class="headerlink" title="如何触发BFC"></a>如何触发BFC</h3><p>根据 <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">Block formatting context-MDN</a> 的文章，只需满足以下条件之一即可：</p><ul><li>根节点或其他东西（好想吐槽一下这个其他东西是什么鬼？求高手指点）。</li><li>浮动（左或右，不包括none）。</li><li>绝对定位（absolute，fixed）。</li><li>display 为以下其中之一的值 inline-blocks，table-cells，table-captions。</li><li>overflow 除了 visible 以外的值。</li><li>CSS3新增的flex boxes（display 为 flex 或 inline-flex）</li></ul><h3 id="BFC的特性"><a href="#BFC的特性" class="headerlink" title="BFC的特性"></a>BFC的特性</h3><ul><li>根据 <a href="http://www.w3.org/TR/CSS21/box.html#collapsing-margins" target="_blank" rel="noopener">CSS 2.1 8.3.1 Collapsing margins</a> 第一条，常规流中的块框在垂直位置的外边距会发生折叠现象。也就是处于同一个BFC中的两个垂直窗口的margin会重叠。</li><li>根据 <a href="http://www.w3.org/TR/CSS21/box.html#collapsing-margins" target="_blank" rel="noopener">CSS 2.1 8.3.1 Collapsing margins</a> 第三条，产生了BFC的元素不会和在流中的子元素发生外边距折叠。所以解决外边距折叠的方法就是产生新的BFC。</li><li>在 BFC 中，每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边）， 即使存在浮动也是如此（尽管一个元素的内容区域会由于浮动而压缩），除非这个元素也创建了一个新的 BFC 。简单来说可以控制浮动元素的浮动区域。</li></ul><h2 id="BFC的实际运用"><a href="#BFC的实际运用" class="headerlink" title="BFC的实际运用"></a>BFC的实际运用</h2><h3 id="阻止外边距折叠"><a href="#阻止外边距折叠" class="headerlink" title="阻止外边距折叠"></a>阻止外边距折叠</h3><p>阻止外边距折叠有多个办法，其中一个就是生成一个新的BFC。只要触发一个BFC条件，外边距的折叠就会被阻止。除了新建一个BFC还可以利用 <code>padding</code>、<code>border-top-width</code> 设置一个非0的值也可。</p><p><img data-src="http://inhu.qiniudn.com/BFC-2.jpg" alt="http://inhu.qiniudn.com/BFC-2.jpg"></p><h3 id="阻止元素被浮动元素覆盖"><a href="#阻止元素被浮动元素覆盖" class="headerlink" title="阻止元素被浮动元素覆盖"></a>阻止元素被浮动元素覆盖</h3><p>浮动元素的块级兄弟元素会无视浮动元素的位置尽量去占满一行，但这样就会导致浮动元素遮挡了兄弟元素。要解决这个遮挡的话，就需要在兄弟的块级元素上实现BFC。</p><p><img data-src="http://inhu.qiniudn.com/BFC-3.jpg" alt="http://inhu.qiniudn.com/BFC-3.jpg"></p><p><strong>需要注意的是，当兄弟元素的宽度大于容器所剩下的宽度的时候便会产生换行。即我们平时清除浮动其实就是使兄弟元素产生新的BFC，以达到换行效果。</strong></p><h2 id="BFC-与-hasLayout"><a href="#BFC-与-hasLayout" class="headerlink" title="BFC 与 hasLayout"></a>BFC 与 hasLayout</h2><p>说到W3C的标准就必须在最后不上IE系列的某些问题，IE6-7由于不支持 W3C 的 BFC 标准，而是使用了私有属性 hasLayout。虽然 hasLayout 与 BFC 在某些方面表现十分相近，但 hasLayout 自身也存在着诸多的问题。hasLayout 笔者不再在这里写了，毕竟谷歌一下都有很详尽的文章。</p>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>H5获取地理位置？不容易！</title>
    <url>/hack/html5-loaction-bug.html</url>
    <content><![CDATA[<p>H5作为未来的趋势已然新增了很多很强大的功能，其中获取设备GPS信息更是强化了H5在手机网页应用的地位。甚至在获取数据的方法上也相当简单，无需复杂的配置只需在JavaScript中简单地调用一下函数。</p><a id="more"></a><p><code>navigator.geolocation.getCurrentPosition(success, error, options)</code></p><p>看上去好像很美好的样子，但其实内里有着很多不可预料的坑在一一等着我们去解决。其中笔者在实际使用过程中发现 <strong>Android大部分机型会存在获取地理位置超时</strong> 的情况。</p><h2 id="国行机型，用户之殇"><a href="#国行机型，用户之殇" class="headerlink" title="国行机型，用户之殇"></a>国行机型，用户之殇</h2><p>当我第一次知道要获取地理位置的时候，其实我是，是拒绝的，我跟产品讲，我拒绝，因为，其实Android有问题。好了，卖了下萌，回归正题！</p><p>一开始搜遍stackoverflow和google groups给出的答案就是试试连上WIFI、试试重启之类无关痛痒的问题。只要是非中文的答案都找不出解决方案，后来发现其实是国行Android由于被阉割了谷歌的GMS服务，导致能正常调用 <code>getCurrentPosition</code> 函数但永远无法触发回调。</p><p>在经过测试后，发现部分国内厂商的浏览器对 <code>getCurrentPosition</code> 进行了重新的封装，其中UC、QQ浏览器都已经重新封装了但对于国际大厂的浏览器由于没有考虑到我国特殊情况所以一律都超时。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="无奈地友情提示"><a href="#无奈地友情提示" class="headerlink" title="无奈地友情提示"></a>无奈地友情提示</h3><p>大部分智能手机都能很好的支持 <code>getCurrentPosition</code> ，但鉴于上面提及的特殊问题我们仍需要判断一下并作出一些提示。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.geolocation) &#123;</span><br><span class="line">    navigator.geolocation.getCurrentPosition(<span class="function"><span class="keyword">function</span>(<span class="params">pos</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// A callback function that takes a Position object as its sole input parameter.</span></span><br><span class="line">        <span class="comment">// 成功回调函数，接受一个地理位置的对象作为参数。</span></span><br><span class="line">        <span class="comment">// https://developer.mozilla.org/en-US/docs/Web/API/Position 参数说明</span></span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// An optional callback function that takes a PositionError object as its sole input parameter.</span></span><br><span class="line">        <span class="comment">// 错误的回调</span></span><br><span class="line">        <span class="comment">// https://developer.mozilla.org/en-US/docs/Web/API/PositionError 错误参数</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        enableHighAccuracy: <span class="literal">true</span>, <span class="comment">// 是否获取高精度结果</span></span><br><span class="line">        timeout: <span class="number">5000</span>, <span class="comment">//超时,毫秒</span></span><br><span class="line">        maximumAge: <span class="number">0</span> <span class="comment">//可以接受多少毫秒的缓存位置</span></span><br><span class="line">        <span class="comment">// 详细说明 https://developer.mozilla.org/en-US/docs/Web/API/PositionOptions</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">'抱歉！您的浏览器无法使用地位功能'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码，可以对不支持 <code>getCurrentPosition</code> 机器作出友好的提示。根据查阅 <a href="https://developer.mozilla.org/en-US/docs/Web/API/PositionError" target="_blank" rel="noopener" title="PositionError">PositionError</a> 可以得知被阉割GMS模块的Android返回的错误码2或者3。</p><h3 id="百度地图的黑魔法"><a href="#百度地图的黑魔法" class="headerlink" title="百度地图的黑魔法"></a>百度地图的黑魔法</h3><p>在实验过程中，笔者在同款浏览器下查看了百度地图令笔者惊讶的是那个小图标屹立在我们的办公区内。但经过各种测试发现其实只是利用了WIFI的IP定位，最终发现只是封装了一下H5原生的<code>geolocation</code>，被阉割的还是被阉割的终究没法完成定位。</p><p>不过百度地图提供的API更为丰富，其中包括了：根据IP定位城市、根据地方名返回坐标等等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉没什么好总结的，这个让我想起了最近支付宝一直被轰说苹果婊，但有时候真的百般无奈。系统被阉割、不完善等不可抗力的原因这个能怪谁？而且有时候问题太特殊了……默哀，为安卓、WinPhone的用户。</p>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>按钮图标与文字对齐</title>
    <url>/hack/vertical-align-baseline-icon-and-text.html</url>
    <content><![CDATA[<p>我们都知道同一段代码在不同浏览器的表现也可能不尽相同，这其中有着浏览器标准不符的原因、也有浏览器本身渲染引擎细微的差距。而最近在做一个带图标的按钮时，缺乏发现按钮的文本下沉了一像素。</p><a id="more"></a><p><a href="http://inhu.net/wp-content/uploads/2015/01/QQ图片20150105182611.png" target="_blank" rel="noopener"><img data-src="http://inhu.net/wp-content/uploads/2015/01/QQ图片20150105182611.png" alt="QQ图片20150105182611" width="475" height="168" class="alignnone size-full wp-image-954"></a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>通过调整 <code>vertical-align</code> 但没办法实现理想的图标与文字效果。</p><p>然后考虑到是浏览器对文字的渲染导致向下偏移了一个像素，这个灵感是来自于中英文之间相差三个像素。最后通过研究腾讯ISUX的文章《<a href="http://isux.tencent.com/website-font-rendering-process.html" target="_blank" rel="noopener">网站字体渲染过程</a>》，发现这是由于系统的字体渲染导致下沉了一像素。</p><p><a href="http://inhu.net/wp-content/uploads/2015/01/20130809152322132.png" target="_blank" rel="noopener"><img data-src="http://inhu.net/wp-content/uploads/2015/01/20130809152322132.png" alt="20130809152322132" width="590" height="295" class="alignnone size-full wp-image-953"></a></p><p>通过文章中的一张对比图可以得出几乎所有浏览器都有下沉一个像素的问题，面对这个下沉的一像素，为了使图标和文本对齐。决定把图标向下移动 <code>1px</code></p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><pre class="lang:sass decode:true">.btn{
    .btn-icon{
        position:relative;
        top:1px;
    }
}</pre>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>Easing公式，JavaScript实现延迟动画</title>
    <url>/hack/easing-equations.html</url>
    <content><![CDATA[<p>好久没更新了，回到老家连抢红包都心塞的网络迫使回归原始生活一段时间，所以连一篇恭贺新禧的文章都懒得发了。</p><p>在过去的马年最后几天，博主在无所事事的时候研究了一下各种各样的<code>easing</code>的公式（博主数学学得烂不要问原理，我只是搬运工）。</p><a id="more"></a><p><a href="http://jsbin.com/nojanu/" target="_blank" rel="noopener">去看看效果</a></p><p>简单的说说这个公式是怎么运用的，分别用4个参数起含义可以看代码的注释，后b、c、d参数基本是固定的值。博主简单举个栗子：</p><p>现在有一个直线动画，由0px（<strong>参数b</strong>）到800px（<strong>参数c</strong>）拆分成1000次运算（<strong>参数d</strong>），当参数t由0逐渐接近参数d的时候，得到的值也会由参数b逐渐接近参数c（也就是说由0px逐渐接近800px）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;Number&#125;</span> </span>t [当前时间点]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;Number&#125;</span> </span>b [开始数值，一般都是0]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;Number&#125;</span> </span>c [最大的值]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;Number&#125;</span> </span>d [时间]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Number&#125;</span>   </span>[算出来的值咯]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> EasingMatch = &#123;</span><br><span class="line">        linearIn: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> c * t / d + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        quinticIn: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            t /= d;</span><br><span class="line">            <span class="keyword">return</span> c * t * t * t * t * t + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        quinticOut: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            t /= d;</span><br><span class="line">            t--;</span><br><span class="line">            <span class="keyword">return</span> c * (t * t * t * t * t + <span class="number">1</span>) + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        quinticIO: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            t /= d / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; <span class="number">1</span>) <span class="keyword">return</span> c / <span class="number">2</span> * t * t * t * t * t + b;</span><br><span class="line">            t -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> c / <span class="number">2</span> * (t * t * t * t * t + <span class="number">2</span>) + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        quadraticIn: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            t /= d;</span><br><span class="line">            <span class="keyword">return</span> c * t * t + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        quadraticOut: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            t /= d;</span><br><span class="line">            <span class="keyword">return</span> -c * t * (t - <span class="number">2</span>) + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        quadraticIO: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            t /= d / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; <span class="number">1</span>) <span class="keyword">return</span> c / <span class="number">2</span> * t * t + b;</span><br><span class="line">            t--;</span><br><span class="line">            <span class="keyword">return</span> -c / <span class="number">2</span> * (t * (t - <span class="number">2</span>) - <span class="number">1</span>) + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        sinusoidalIn: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -c * <span class="built_in">Math</span>.cos(t / d * (<span class="built_in">Math</span>.PI / <span class="number">2</span>)) + c + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        sinusoidalOut: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> c * <span class="built_in">Math</span>.sin(t / d * (<span class="built_in">Math</span>.PI / <span class="number">2</span>)) + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        sinusoidalIO: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -c / <span class="number">2</span> * (<span class="built_in">Math</span>.cos(<span class="built_in">Math</span>.PI * t / d) - <span class="number">1</span>) + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        cubicIn: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            t /= d;</span><br><span class="line">            <span class="keyword">return</span> c * t * t * t + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        cubicOut: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            t /= d;</span><br><span class="line">            t--;</span><br><span class="line">            <span class="keyword">return</span> c * (t * t * t + <span class="number">1</span>) + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        cubicIO: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            t /= d / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; <span class="number">1</span>) <span class="keyword">return</span> c / <span class="number">2</span> * t * t * t + b;</span><br><span class="line">            t -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> c / <span class="number">2</span> * (t * t * t + <span class="number">2</span>) + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        expIn: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> c * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">10</span> * (t / d - <span class="number">1</span>)) + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        expOut: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> c * (-<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-10</span> * t / d) + <span class="number">1</span>) + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        expIO: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            t /= d / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; <span class="number">1</span>) <span class="keyword">return</span> c / <span class="number">2</span> * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">10</span> * (t - <span class="number">1</span>)) + b;</span><br><span class="line">            t--;</span><br><span class="line">            <span class="keyword">return</span> c / <span class="number">2</span> * (-<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-10</span> * t) + <span class="number">2</span>) + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        quartiIn: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            t /= d;</span><br><span class="line">            <span class="keyword">return</span> c * t * t * t * t + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        quartiOut: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            t /= d;</span><br><span class="line">            t--;</span><br><span class="line">            <span class="keyword">return</span> -c * (t * t * t * t - <span class="number">1</span>) + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        quartiIO: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            t /= d / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; <span class="number">1</span>) <span class="keyword">return</span> c / <span class="number">2</span> * t * t * t * t + b;</span><br><span class="line">            t -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> -c / <span class="number">2</span> * (t * t * t * t - <span class="number">2</span>) + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        circularIn: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            t /= d;</span><br><span class="line">            <span class="keyword">return</span> -c * (<span class="built_in">Math</span>.sqrt(<span class="number">1</span> - t * t) - <span class="number">1</span>) + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        circularOut: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            t /= d;</span><br><span class="line">            t--;</span><br><span class="line">            <span class="keyword">return</span> c * <span class="built_in">Math</span>.sqrt(<span class="number">1</span> - t * t) + b;</span><br><span class="line">        &#125;,</span><br><span class="line">        circularIO: <span class="function"><span class="keyword">function</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line">            t /= d / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; <span class="number">1</span>) <span class="keyword">return</span> -c / <span class="number">2</span> * (<span class="built_in">Math</span>.sqrt(<span class="number">1</span> - t * t) - <span class="number">1</span>) + b;</span><br><span class="line">            t -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> c / <span class="number">2</span> * (<span class="built_in">Math</span>.sqrt(<span class="number">1</span> - t * t) + <span class="number">1</span>) + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单使用例子</span></span><br><span class="line"><span class="keyword">var</span> curTime  = <span class="number">0</span>,</span><br><span class="line">makeAnimation = <span class="function"><span class="keyword">function</span>(<span class="params">left</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#animationBall'</span>).css(&#123;</span><br><span class="line">        left: (left + <span class="number">10</span>) + <span class="string">'px'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= maxWidth)&#123;</span><br><span class="line">        curTime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        curTime++;</span><br><span class="line">        makeAnimation(EasingMatch.circularIO(curTime, <span class="number">0</span>, maxWidth, <span class="number">800</span>));</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line">makeAnimation(EasingMatch.circularIO(curTime, <span class="number">0</span>, maxWidth, <span class="number">800</span>));</span><br></pre></td></tr></table></figure><p>如果不想使用Js的话，下面送你们一个CSS的……</p><p><a href="http://matthewlein.com/ceaser/" target="_blank" rel="noopener">CSS3 公式</a></p>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>实现文字背景图片</title>
    <url>/hack/font-background-image.html</url>
    <content><![CDATA[<p>最近在实现一个手机上黑板的效果，黑板上的文字都是粉笔效果这个如果放在以前的确很为难，这样子弄只能所有文字都切成一张张透明的图片，但幸好现在高端智能手机已经支持CSS3，那么我们就利用CSS3属性来实现粉笔字的效果。</p><a id="more"></a><p><img data-src="http://inhu.qiniudn.com/219077-120Z41R33785.jpg?imageView2/1/w/700/h/200/q/85" alt="Blackboard"></p><h2 id="背景裁剪和字体透明"><a href="#背景裁剪和字体透明" class="headerlink" title="背景裁剪和字体透明"></a>背景裁剪和字体透明</h2><p>实现粉笔字的效果其实就是简单的利用背景裁剪和字体透明，最直接的思路就是设置文字的背景图片，但在CSS3并不支持文字设置背景图片而这个时候我们可以采用<code>-webkit-background-clip</code> 和 <code>-webkit-text-fill-color: transparent</code>。</p><p>那我们大致理解了原理之后，就开始动工了。笔者随便弄了张噪点的背景图（不太会PS，将就将就吧，我们看实现的过程不看结果。T_T）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.blackboard-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#2f4e31</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.blackboard-wrap</span> <span class="selector-class">.blackboard</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>:auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">62px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bolder;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(http://inhu.qiniudn.com/blackboard-font-bg.png);</span><br><span class="line">  <span class="attribute">-webkit-background-clip</span>: text;</span><br><span class="line">  <span class="attribute">-webkit-text-fill-color</span>: transparent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="兼容问题"><a href="#兼容问题" class="headerlink" title="兼容问题!!"></a>兼容问题!!</h2><p>使用最新最潮的技术免不了要付出点兼容的代价，虽然在手机上大部分浏览器已经支持<code>background-clip</code>了，但仍不支持裁剪到<code>text</code>的程度。所以免不了有些手机只看到背景图片连文字都看不到，这时候我们就需要请出 <strong>modernizr</strong> 来做兼容处理。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 判断是否支持background-clip:text,如果不支持在body上添加不支持的类 */</span></span><br><span class="line"><span class="keyword">if</span>(!Modernizr.testAllProps(<span class="string">'backgroundClip'</span>, <span class="string">'text'</span>))&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].className +=<span class="string">" not-support-bgclip-text"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.blackboard-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#2f4e31</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.blackboard-wrap</span> <span class="selector-class">.blackboard</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>:auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">62px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bolder;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(http://inhu.qiniudn.com/blackboard-font-bg.png);</span><br><span class="line">  <span class="attribute">-webkit-background-clip</span>: text;</span><br><span class="line">  <span class="attribute">-webkit-text-fill-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.not-support-bgclip-text .blackboard-wrap .blackboard &#123; //降级处理</span><br><span class="line">    <span class="selector-tag">background</span><span class="selector-pseudo">:transparent</span>;</span><br><span class="line">    <span class="selector-tag">color</span>:<span class="selector-id">#efefef</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多好玩的"><a href="#更多好玩的" class="headerlink" title="更多好玩的"></a>更多好玩的</h2><p>利用CSS3这两个新的特性，我们不仅仅可以做个黑板粉笔字，还可以实现彩虹、渐变等字体的样式。更多的玩法大家可以琢磨琢磨。</p><p><a class="jsbin-embed" href="http://jsbin.com/xedeho/1/embed?output" target="_blank" rel="noopener">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script></p>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>Android下的borderRadius</title>
    <url>/hack/android-borderRadius.html</url>
    <content><![CDATA[<p><code>border-radius</code> 的出现算是一次革命性的更新，在老一辈的记忆中圆角的实现都是采用图片的统一解决方案，但随着CSS3发布和浏览器支持圆角的实现逐渐变得轻松起来，<code>border-radius</code> 也开始被广泛应用。</p><a id="more"></a><p>随着移动设备的普及，前端的工作不在仅仅在电脑上的浏览器做兼容，也需要去做移动设备的兼容，虽然 <code>border-radius</code> 在桌面上已经相当成熟，但在安卓设备上仍是需要花费不小心思去做兼容。</p><p>这里以做一个圆形的图片为例子，来探讨一下Android下都有什么坑。</p><h2>Android 2.3 不支持 % 百分号</h2><p>一般需要实现圆形的图片只需要 <code>border-radius:50%</code> 就可以实现圆形的效果，但偏偏Android 2.3 版本并不支持百分号的写法。</p><pre class="decode:true lang:css">//在android 2.3 下没办法实现圆形图片
.round img{
    border-radius: 50%; //实现圆形
    border: 4px solid white; //描边
}

//修改后
.round img{
    border-radius: 999px; //实现圆形，设置较大的圆角像素强迫形成一个圆形
    border: 4px solid white; //描边
}
</pre><h2>某些低版本的 Android 和 Safari 会存在圆角问题</h2><p>某些低版本的设备对于同时存在 <code>border</code> 和 <code>border-radius</code> 的 <code>img</code> 元素会出问题，圆形还是圆形但是图片是正方的。</p><p><a href="http://inhu.net/wp-content/uploads/2015/02/未标题-1.jpg" target="_blank" rel="noopener"><img data-src="http://inhu.net/wp-content/uploads/2015/02/未标题-1.jpg" alt="未标题-1" width="400" height="200" class="alignnone size-full wp-image-968"></a></p><p>左侧为希望实现的效果图，但在某些低版本设备中会出现右侧的情况。很显然这种现实效果不是我们希望看到的。</p><p>让我们通过下面的图片探究一下为什么会这样吧。</p><p><a href="http://inhu.net/wp-content/uploads/2015/02/border-radius-01.jpg" target="_blank" rel="noopener"><img data-src="http://inhu.net/wp-content/uploads/2015/02/border-radius-01.jpg" alt="border-radius-01" width="600" height="800" class="alignnone size-full wp-image-969"></a></p><p>显然这一切都是因为浏览器以最外边距开始裁剪导致的问题，那么我只需要保持内容区域以外都是”干净“的就可以了。</p><p>实现方式为在图片内容的外层添加边框。</p><pre class="decode:true lang:css">.round{
    display-inline: block;
    border-radius: 999px; //为了外层的边框也是圆形
    vertical-align: middle; //使图片垂直居中,如果不垂直居中将会发现上边
    border: 4px solid white; //描边
}
.round img{
    border-radius: 999px; //实现圆形，设置较大的圆角像素强迫形成一个圆形
    vertical-align: middle; //使图片垂直居中
}
</pre><h2>圆形背景色不裁剪</h2><p>同时设置<code>border-radius</code>和<code>background-color</code>时，背景色并没有裁剪。这显然也是某些版本的浏览器的BUG，这个时候只需要添加<code>background-clip: padding-box;</code>来修复。</p><pre class="decode:true lang:css">.round{
    display-inline: block;
    border-radius: 999px; //为了外层的边框也是圆形
    vertical-align: middle; //使图片垂直居中,如果不垂直居中将会发现上边
    border: 4px solid white; //描边
}
.round img{
    border-radius: 999px; //实现圆形，设置较大的圆角像素强迫形成一个圆形
    vertical-align: middle; //使图片垂直居中
    background-color: #eee;
    background-clip: padding-box;
}
</pre><h3>其他问题</h3><p>据另外一篇文章说，还有一种情况就是不支持<code>border-radius</code>缩写，需要完整的写出扩写属性。但笔者还没有遇到过这种情况，如果发现<code>border-radius</code>不好使的时候，可以试试以下方法：</p><pre class="decode:true lang:css">    border-top-left-radius: 999px; // 左上角
    border-top-right-radius: 999px; // 右上角
    border-bottom-right-radius: 999px; // 右下角
    border-bottom-left-radius: 999px; // 左下角
</pre>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular-UEditor</title>
    <url>/hack/publish-angular-ueditor.html</url>
    <content><![CDATA[<p>angualr 作为最近前端大热的一款框架，越来越多国人开始使用并且不断有成功的项目。UEditor作为百度前端团队的一款神器，在国内多个项目也在使用。所以小编抽了个时间把angular和UEditor整合起来作为一款angular的插件。</p><a id="more"></a><h3 id="2015年3月19日更新-关于图片上传的问题"><a href="#2015年3月19日更新-关于图片上传的问题" class="headerlink" title="2015年3月19日更新 关于图片上传的问题"></a>2015年3月19日更新 关于图片上传的问题</h3><blockquote><p>由于UEditor 对图片上传的操作时插入了一个元素（上传中…）的内容但对于后续操作UEditor都采用了对该元素直接进行操作没有触发到contentChange事件。我已经向UEditor的开发团队提交了issue，所以还是需要等他们来解决这个问题。相关细节的代码参考-&gt; <a href="https://github.com/fex-team/ueditor/blob/dcd825c969506cef8ebed71b324e4e9e4793b335/_src/plugins/simpleupload.js#L61-L97" target="_blank" rel="noopener">simpleupload.js</a></p></blockquote><h2 id="angular-ueditor"><a href="#angular-ueditor" class="headerlink" title="angular-ueditor"></a>angular-ueditor</h2><p>angular-ueditor 是一款整合了 angular 和 UEditor 的插件。目的是为了更方便的在angular基础上使用UEditor。</p><p><strong><a href="https://github.com/zqjimlove/angular-ueditor" target="_blank" rel="noopener">Github</a>地址</strong></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><a href="http://zqjimlove.github.io/angular-ueditor/sample/demo.html" target="_blank" rel="noopener">http://zqjimlove.github.io/angular-ueditor/sample/demo.html</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>先引入 UEditor 的 javascript 文件</p><pre class="lang:xhtml decode:true">&lt;script type="text/javascript" src="/ueditor/ueditor.config.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/ueditor/ueditor.all.js"&gt;&lt;/script&gt;</pre><p>然后下载最新的 <a href="https://github.com/zqjimlove/angular-ueditor/tree/master/dist" target="_blank" rel="noopener">angular-ueditor</a> 并且引入文件</p><pre class="lang:xhtml decode:true">&lt;script type="text/javascript" src="angular-ueditor.js"&gt;&lt;/script&gt;</pre><p>此时还需要把 angular-ueditor 引入到模块里</p><pre class="lang:js decode:true">angular.module('app', ['ng.ueditor'])</pre><h3 id="用-Bower-安装"><a href="#用-Bower-安装" class="headerlink" title="用 Bower 安装"></a>用 Bower 安装</h3><p>使用 Bower 安装时，angular-ueditor 会自动安装并且引入，但ueditor由于没有加入到 Bower 所以需要手动引入。</p><pre class="lang:sh decode:true">bower install angular-ueditor --save</pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h5 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h5><p><strong>由于继承了NgModelController，必须绑定 <code>ngModel</code></strong></p><pre class="lang:xhtml decode:true">&lt;div class="ueditor" ng-model="content"&gt;&lt;/div&gt;</pre><h5 id="自定义编辑器"><a href="#自定义编辑器" class="headerlink" title="自定义编辑器"></a>自定义编辑器</h5><pre class="lang:xhtml decode:true">&lt;div class="ueditor" config="config" ng-model="content"&gt;&lt;/div&gt;
...
&lt;script&gt;
    $scope.config = {
        ...
    }
&lt;/script&gt;</pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="ready-listener"><a href="#ready-listener" class="headerlink" title="ready(listener)"></a><code>ready(listener)</code></h3><p>注册准备事件，当 editor 初始化完成后会执行回调函数。</p><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><table><thead><tr><th>参数</th><th>类型</th><th>详细</th></tr></thead><tbody><tr><td>listener</td><td>function(editor)</td><td>Callback called whenever the editor ready.</td></tr></tbody></table><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><pre class="lang:xhtml decode:true">&lt;div class="ueditor" ready="ready" ng-model="content"&gt;&lt;/div&gt;
...
&lt;script type="text/javascript"&gt;
    $scope.ready = function(editor){
        alert(editor.getContent());
    }
&lt;/script&gt;</pre><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>这算是小编第一次正正经经的发布一个开源的项目，即使项目技术含量不高但实在又难以言表的愉悦。在最初开始学习编程到今天，使用过的开源项目数不胜数一直在学习、膜拜各路大神级的开源人物，这一次总算小小回馈了一下。希望在未来能带给大家更多方便好用的项目。</p>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
